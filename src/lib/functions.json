[
  {
    "define": "_functions.Math.Abs",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the absolute value of a number.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the absolute value of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.abs($$args.number);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The absolute value of the number."
    },
    "tests": {
      "absPositive": {
        "description": "Calculate the absolute value of a positive number.",
        "input": {
          "number": 5
        },
        "expected": 5
      },
      "absNegative": {
        "description": "Calculate the absolute value of a negative number.",
        "input": {
          "number": -5
        },
        "expected": 5
      },
      "absZero": {
        "description": "Calculate the absolute value of zero.",
        "input": {
          "number": 0
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Math.Acos",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the arccosine (inverse cosine) of a number.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the arccosine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.acos($$args.number);\n"
      }
    },
    "returns": {
      "type": "_types.Math",
      "description": "The arccosine of the number in radians."
    },
    "tests": {
      "acosZero": {
        "description": "Calculate the arccosine of 0.",
        "input": {
          "number": 0
        },
        "expected": 1.5707963267948966
      },
      "acosOne": {
        "description": "Calculate the arccosine of 1.",
        "input": {
          "number": 1
        },
        "expected": 0
      },
      "acosMinusOne": {
        "description": "Calculate the arccosine of -1.",
        "input": {
          "number": -1
        },
        "expected": 3.141592653589793
      }
    }
  },
  {
    "define": "_functions.Math.Acosec",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the inverse cosecant of an angle (in radians).",
    "parameters": {
      "x": {
        "type": "_types.Number",
        "description": "The value for which to calculate the inverse cosecant."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if (Math.abs($$args.x) < 1) {\n  throw new Error(\"Invalid input: |x| must be >= 1\");\n}\nreturn Math.asin(1 / $$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Math",
      "description": "The inverse cosecant of the angle."
    },
    "tests": {
      "acosecOne": {
        "description": "Calculate the inverse cosecant of 1.",
        "input": {
          "x": 1
        },
        "expected": 1.5707963267948966
      },
      "acosecNegativeOne": {
        "description": "Calculate the inverse cosecant of -1.",
        "input": {
          "x": -1
        },
        "expected": -1.5707963267948966
      },
      "acosecGreaterThanOne": {
        "description": "Calculate the inverse cosecant of 2.",
        "input": {
          "x": 2
        },
        "expected": 0.5235987755982989
      },
      "acosecNegativeGreaterThanOne": {
        "description": "Calculate the inverse cosecant of -2.",
        "input": {
          "x": -2
        },
        "expected": -0.5235987755982989
      }
    }
  },
  {
    "define": "_functions.Math.Acosh",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the inverse hyperbolic cosine of a number.",
    "parameters": {
      "x": {
        "type": "_types.Number",
        "description": "The input value to calculate the inverse hyperbolic cosine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.acosh($$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Math",
      "description": "The inverse hyperbolic cosine of the input value."
    },
    "tests": {
      "acoshOne": {
        "description": "Calculate the inverse hyperbolic cosine of 1.",
        "input": {
          "x": 1
        },
        "expected": 0
      },
      "acoshTwo": {
        "description": "Calculate the inverse hyperbolic cosine of 2.",
        "input": {
          "x": 2
        },
        "expected": 1.3169578969248166
      }
    }
  },
  {
    "define": "_functions.Math.Acot",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Given a number, calculates its arccotangent (inverse cotangent).",
    "parameters": {
      "x": {
        "type": "_types.Number",
        "description": "The number to calculate the arccotangent of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.x === 0) {\n  return Math.PI / 2;\n}\nreturn Math.atan(1 / $$args.x);\n"
      }
    },
    "returns": {
      "type": "Math",
      "description": "The arccotangent of the given number."
    },
    "tests": {
      "acotOne": {
        "description": "Calculate the arccotangent of 1.",
        "input": {
          "x": 1
        },
        "expected": 0.7853981633974483
      },
      "acotZero": {
        "description": "Calculate the arccotangent of 0.",
        "input": {
          "x": 0
        },
        "expected": 1.5707963267948966
      },
      "acotNegativeOne": {
        "description": "Calculate the arccotangent of -1.",
        "input": {
          "x": -1
        },
        "expected": -0.7853981633974483
      },
      "acotPiOverTwo": {
        "description": "Calculate the arccotangent of Ï€/2.",
        "input": {
          "x": 1.5707963267948966
        },
        "expected": 0.5669115049410094
      }
    }
  },
  {
    "define": "_functions.Math.Acoth",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the inverse hyperbolic cotangent of a given number.",
    "parameters": {
      "x": {
        "type": "_types.Math",
        "description": "The input value for which to calculate the inverse hyperbolic cotangent."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function acoth(x) {\n  if (x <= 1 && x >= -1) {\n    throw new Error(\"Invalid input: x must be greater than 1 or less than -1\");\n  }\n  return 0.5 * Math.log((x + 1) / (x - 1));\n}\nreturn acoth($$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The inverse hyperbolic cotangent of the input value."
    },
    "tests": {
      "acothOne": {
        "description": "Calculate the inverse hyperbolic cotangent of 1.",
        "input": {
          "x": 1.01
        },
        "expected": 2.6516524540295374
      },
      "acothNegativeOne": {
        "description": "Calculate the inverse hyperbolic cotangent of -1.",
        "input": {
          "x": -1.01
        },
        "expected": -2.6516524540295374
      },
      "acothGreaterThanOne": {
        "description": "Calculate the inverse hyperbolic cotangent of 2.",
        "input": {
          "x": 2
        },
        "expected": 0.5493061443340549
      },
      "acothLessThanNegativeOne": {
        "description": "Calculate the inverse hyperbolic cotangent of -2.",
        "input": {
          "x": -2
        },
        "expected": -0.5493061443340549
      }
    }
  },
  {
    "define": "_functions.Math.Add",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Add two numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The numbers to add."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.numbers.reduce((sum, curr) => sum + curr, 0)\n"
      }
    },
    "returns": {
      "type": "_types.Math",
      "description": "The sum of the two numbers."
    },
    "tests": {
      "addTwo": {
        "description": "Add two numbers.",
        "input": {
          "numbers": [1, 2]
        },
        "expected": 3
      },
      "addThree": {
        "description": "Add three numbers.",
        "input": {
          "numbers": [2, 3, 10]
        },
        "expected": 15
      }
    }
  },
  {
    "define": "_functions.Date.AddDuration",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Adds a given duration to an input date.",
    "parameters": {
      "startDate": {
        "type": "_types.Date",
        "description": "The starting date to add the duration from."
      },
      "duration": {
        "type": "_types.Number",
        "description": "The duration in seconds to add to the starting date."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const startDate = new Date($$args.startDate);\nconst durationInMilliseconds = $$args.duration * 1000;\nreturn new Date(startDate.getTime() + durationInMilliseconds).toString();\n"
      }
    },
    "returns": {
      "type": "_types.Date",
      "description": "The resulting date after adding the given duration."
    },
    "tests": {
      "addDurationOneDay": {
        "description": "Add one day (86400 seconds) to a starting date.",
        "input": {
          "startDate": "2022-01-01T00:00:00.000Z",
          "duration": 86400
        },
        "expected": "Sun Jan 02 2022 00:00:00 GMT+0000 (Coordinated Universal Time)"
      },
      "addDurationOneHour": {
        "description": "Add one hour (3600 seconds) to a starting date.",
        "input": {
          "startDate": "2022-01-01T12:00:00.000Z",
          "duration": 3600
        },
        "expected": "Sat Jan 01 2022 13:00:00 GMT+0000 (Coordinated Universal Time)"
      },
      "addDurationOneMinute": {
        "description": "Add one minute (60 seconds) to a starting date.",
        "input": {
          "startDate": "2022-01-01T12:30:00.000Z",
          "duration": 60
        },
        "expected": "Sat Jan 01 2022 12:31:00 GMT+0000 (Coordinated Universal Time)"
      }
    }
  },
  {
    "define": "_functions.String.Alpha",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the alphabetic characters of a given text, removing any non-alphabetic characters.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The input text to process."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = /[a-zA-Z]/g;\nreturn $$args.text.match(regex).join('');\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The alphabetic characters of the input text."
    },
    "tests": {
      "alphaSimple": {
        "description": "Extract the alphabetic characters from a simple string.",
        "input": {
          "text": "hello world"
        },
        "expected": "helloworld"
      },
      "alphaMultipleWords": {
        "description": "Extract the alphabetic characters from multiple words.",
        "input": {
          "text": "This is an example sentence"
        },
        "expected": "Thisisanexamplesentence"
      },
      "alphaWithNumbersAndSymbols": {
        "description": "Extract the alphabetic characters from a string with numbers and symbols.",
        "input": {
          "text": "abc123!@#def456"
        },
        "expected": "abcdef"
      }
    }
  },
  {
    "define": "_functions.String.AppendUrlParameters",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Appends URL parameters to a given URL.",
    "parameters": {
      "url": {
        "type": "_types.String",
        "description": "The base URL."
      },
      "params": {
        "type": "_types.Dictionary",
        "description": "A dictionary of key-value pairs representing the URL parameters."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let newUrl = $$args.url;\nfor (const [key, value] of Object.entries($$args.params)) {\n  newUrl += `&${key}=${value}`;\n}\nreturn newUrl;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The URL with appended parameters."
    },
    "tests": {
      "appendUrlParametersSimple": {
        "description": "Append simple parameters.",
        "input": {
          "url": "https://example.com",
          "params": {
            "foo": "bar",
            "baz": "qux"
          }
        },
        "expected": "https://example.com&foo=bar&baz=qux"
      },
      "appendUrlParametersMultipleValues": {
        "description": "Append multiple values for the same key.",
        "input": {
          "url": "https://example.com",
          "params": {
            "foo": ["bar", "baz"]
          }
        },
        "expected": "https://example.com&foo=bar,baz"
      }
    }
  },
  {
    "define": "_functions.Math.Asec",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the arcsecant of a value.",
    "parameters": {
      "x": {
        "type": "_types.Number",
        "description": "The value to calculate the arcsecant of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function asec(x) {\n  if (Math.abs(x) < 1) {\n    throw new Error(\"Invalid input: |x| must be >= 1\");\n  }\n  return Math.acos(1 / x);\n}\nreturn asec($$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The arcsecant of the value."
    },
    "tests": {
      "asecOne": {
        "description": "Calculate the arcsecant of 1.",
        "input": {
          "x": 1
        },
        "expected": 0
      },
      "asecNegativeOne": {
        "description": "Calculate the arcsecant of -1.",
        "input": {
          "x": -1
        },
        "expected": 3.141592653589793
      },
      "asecTwo": {
        "description": "Calculate the arcsecant of 2.",
        "input": {
          "x": 2
        },
        "expected": 1.0471975511965979
      },
      "asecNegativeTwo": {
        "description": "Calculate the arcsecant of -2.",
        "input": {
          "x": -2
        },
        "expected": 2.0943951023931957
      }
    }
  },
  {
    "define": "_functions.Math.Asin",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the arcsine (inverse sine) of a number.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the arcsine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.asin($$args.number);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The arcsine of the number in radians."
    },
    "tests": {
      "asinZero": {
        "description": "Calculate the arcsine of 0.",
        "input": {
          "number": 0
        },
        "expected": 0
      },
      "asinOne": {
        "description": "Calculate the arcsine of 1.",
        "input": {
          "number": 1
        },
        "expected": 1.5707963267948966
      },
      "asinMinusOne": {
        "description": "Calculate the arcsine of -1.",
        "input": {
          "number": -1
        },
        "expected": -1.5707963267948966
      }
    }
  },
  {
    "define": "_functions.Math.Asinh",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the inverse hyperbolic sine of a number.",
    "parameters": {
      "x": {
        "type": "_types.Number",
        "description": "The input value for which to calculate the inverse hyperbolic sine."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.asinh($$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The inverse hyperbolic sine of the input value."
    },
    "tests": {
      "asinhPositive": {
        "description": "Calculate the inverse hyperbolic sine of a positive number.",
        "input": {
          "x": 1.5
        },
        "expected": 1.1947632172871094
      },
      "asinhNegative": {
        "description": "Calculate the inverse hyperbolic sine of a negative number.",
        "input": {
          "x": -1.5
        },
        "expected": -1.1947632172871094
      }
    }
  },
  {
    "define": "_functions.Math.Atan",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the arctangent (inverse tangent) of a number.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the arctangent of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.atan($$args.number);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The arctangent of the number in radians."
    },
    "tests": {
      "atanZero": {
        "description": "Calculate the arctangent of 0.",
        "input": {
          "number": 0
        },
        "expected": 0
      },
      "atanOne": {
        "description": "Calculate the arctangent of 1.",
        "input": {
          "number": 1
        },
        "expected": 0.7853981633974483
      },
      "atanMinusOne": {
        "description": "Calculate the arctangent of -1.",
        "input": {
          "number": -1
        },
        "expected": -0.7853981633974483
      }
    }
  },
  {
    "define": "_functions.Math.Atanh",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the inverse hyperbolic tangent of a given number.",
    "parameters": {
      "arg0": {
        "type": "_types.Number",
        "description": "The input value to calculate the inverse hyperbolic tangent for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function atanh(x) {\n  if (x <= -1 || x >= 1) {\n    throw new Error(\"Invalid input: |x| must be less than 1\");\n  }\n  return Math.atanh(x);\n}\nreturn atanh($$args.arg0);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The inverse hyperbolic tangent of the input value."
    },
    "tests": {
      "atanhZero": {
        "description": "Calculate the inverse hyperbolic tangent of 0.",
        "input": {
          "arg0": 0
        },
        "expected": 0
      },
      "atanhPositive": {
        "description": "Calculate the inverse hyperbolic tangent of 0.5.",
        "input": {
          "arg0": 0.5
        },
        "expected": 0.5493061443340548
      },
      "atanhNegative": {
        "description": "Calculate the inverse hyperbolic tangent of -0.5.",
        "input": {
          "arg0": -0.5
        },
        "expected": -0.5493061443340548
      }
    }
  },
  {
    "define": "_functions.Math.Average",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the average of a list of numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The list of numbers to average.",
        "items": {
          "type": "_types.Number"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "const sum = $$args.numbers.reduce((sum, curr) => sum + curr, 0);\nreturn sum / $$args.numbers.length;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The average of the numbers."
    },
    "tests": {
      "averageTwo": {
        "description": "Calculate the average of two numbers.",
        "input": {
          "numbers": [4, 8]
        },
        "expected": 6
      },
      "averageThree": {
        "description": "Calculate the average of three numbers.",
        "input": {
          "numbers": [10, 20, 30]
        },
        "expected": 20
      }
    }
  },
  {
    "define": "_functions.Math.BesselI",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Evaluates the Bessel function of the first kind (Iv(x)).",
    "parameters": {
      "v": {
        "type": "_types.Number",
        "description": "The order of the Bessel function."
      },
      "x": {
        "type": "_types.Number",
        "description": "The input value to evaluate the Bessel function for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function besselI(v, x) {\n  if (v === 0) {\n    let sum = 1;\n    let term = 1;\n    for (let k = 1; k < 100; k++) {\n      term *= (x / 2) * (x / 2) / (k * k);\n      sum += term;\n      if (term < 1e-15) break;\n    }\n    return sum;\n  } else {\n    throw new Error(\"This implementation only supports the Bessel function of order 0.\");\n  }\n}\nreturn besselI($$args.v, $$args.x);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The result of evaluating the Bessel function."
    },
    "tests": {
      "besselIZeroOrder": {
        "description": "Calculate the Bessel function of the first kind for order 0.",
        "input": {
          "v": 0,
          "x": 1.2
        },
        "expected": 1.393725584134064
      },
      "besselICalculation": {
        "description": "Calculate the Bessel function of the first kind for a given order and value.",
        "input": {
          "v": 0,
          "x": 2.5
        },
        "expected": 3.289839144050123
      }
    }
  },
  {
    "define": "_functions.Math.BitAnd",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Performs a bitwise AND operation on two numbers.",
    "parameters": {
      "left": {
        "type": "_types.Number",
        "description": "The first number to perform the bitwise AND operation on."
      },
      "right": {
        "type": "_types.Number",
        "description": "The second number to perform the bitwise AND operation on."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.left & $$args.right;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The result of the bitwise AND operation."
    },
    "tests": {
      "bitAndSameBits": {
        "description": "Test a bitwise AND operation where both numbers have the same bits.",
        "input": {
          "left": 3,
          "right": 3
        },
        "expected": 3
      },
      "bitAndDifferentBits": {
        "description": "Test a bitwise AND operation where the numbers have different bits.",
        "input": {
          "left": 5,
          "right": 2
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Logical.BitNot",
    "blueprint": "_blueprint.Flowgraph",
    "description": "The Bit Not function performs a bitwise NOT operation on the given boolean value.",
    "parameters": {
      "input": {
        "type": "_types.Boolean",
        "description": "The boolean value to perform the bitwise NOT operation on."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return !($$args.input);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "The result of performing a bitwise NOT operation on the given boolean value."
    },
    "tests": {
      "bitNotTrue": {
        "description": "Perform bitwise NOT on true.",
        "input": {
          "input": true
        },
        "expected": false
      },
      "bitNotFalse": {
        "description": "Perform bitwise NOT on false.",
        "input": {
          "input": false
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.Or",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Performs a bitwise OR operation on the given numbers.",
    "parameters": {
      "left": {
        "type": "_types.Number",
        "description": "The first number to perform the OR operation on."
      },
      "right": {
        "type": "_types.Number",
        "description": "The second number to perform the OR operation on."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.left | $$args.right;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The result of the bitwise OR operation."
    },
    "tests": {
      "bitOr0And0": {
        "description": "Perform a bitwise OR operation with both operands being 0.",
        "input": {
          "left": 0,
          "right": 0
        },
        "expected": 0
      },
      "bitOr1And1": {
        "description": "Perform a bitwise OR operation with both operands being 1.",
        "input": {
          "left": 1,
          "right": 1
        },
        "expected": 1
      },
      "bitOr0And1": {
        "description": "Perform a bitwise OR operation with one operand being 0 and the other being 1.",
        "input": {
          "left": 0,
          "right": 1
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.BitShiftLeft",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Shifts the bits of a number to the left.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to shift."
      },
      "count": {
        "type": "_types.Number",
        "description": "The number of positions to shift."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value << $$args.count;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The result of the bit shift operation."
    },
    "tests": {
      "bitShiftLeftOnePosition": {
        "description": "Shift a value one position to the left.",
        "input": {
          "value": 8,
          "count": 1
        },
        "expected": 16
      },
      "bitShiftLeftMultiplePositions": {
        "description": "Shift a value multiple positions to the left.",
        "input": {
          "value": 8,
          "count": 3
        },
        "expected": 64
      }
    }
  },
  {
    "define": "_functions.Math.BitShiftRight",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Shifts the bits of a number to the right.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The number to shift."
      },
      "bits": {
        "type": "_types.Number",
        "description": "The number of bits to shift."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value >> $$args.bits;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The result of the bit shift operation."
    },
    "tests": {
      "bitShiftRightSimple": {
        "description": "Shift a simple value.",
        "input": {
          "value": 8,
          "bits": 2
        },
        "expected": 2
      },
      "bitShiftRightMultipleBits": {
        "description": "Shift multiple bits.",
        "input": {
          "value": 16,
          "bits": 4
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.BitXor",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Performs a bitwise XOR operation on the input values.",
    "parameters": {
      "first": {
        "type": "_types.Any",
        "description": "The first value to perform the XOR operation on."
      },
      "second": {
        "type": "_types.Any",
        "description": "The second value to perform the XOR operation on."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return !!($$args.first ^ $$args.second);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "The result of the bitwise XOR operation."
    },
    "tests": {
      "bitXorTrueTrue": {
        "description": "Perform a bitwise XOR operation with both inputs as true.",
        "input": {
          "first": true,
          "second": true
        },
        "expected": false
      },
      "bitXorFalseFalse": {
        "description": "Perform a bitwise XOR operation with both inputs as false.",
        "input": {
          "first": false,
          "second": false
        },
        "expected": false
      },
      "bitXorTrueFalse": {
        "description": "Perform a bitwise XOR operation with the first input as true and the second as false.",
        "input": {
          "first": true,
          "second": false
        },
        "expected": true
      },
      "bitXorFalseTrue": {
        "description": "Perform a bitwise XOR operation with the first input as false and the second as true.",
        "input": {
          "first": false,
          "second": true
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Logical.And",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the logical AND of two boolean values.",
    "parameters": {
      "a": {
        "type": "_types.Boolean",
        "description": "The first boolean value."
      },
      "b": {
        "type": "_types.Boolean",
        "description": "The second boolean value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a && $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "The result of the logical AND operation."
    },
    "tests": {
      "andTrueTrue": {
        "description": "Both input values are true.",
        "input": {
          "a": true,
          "b": true
        },
        "expected": true
      },
      "andFalseTrue": {
        "description": "First input value is false, second is true.",
        "input": {
          "a": false,
          "b": true
        },
        "expected": false
      },
      "andTrueFalse": {
        "description": "First input value is true, second is false.",
        "input": {
          "a": true,
          "b": false
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Dictionary.BuildObject",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Builds a new dictionary with the given keys and values.",
    "parameters": {
      "data": {
        "type": "_types.Dictionary",
        "description": "The dictionary to build from."
      },
      "keys": {
        "type": "_types.List",
        "description": "The list of keys to select from the input dictionary."
      },
      "values": {
        "type": "_types.List",
        "description": "The list of values corresponding to the keys."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const obj = {};\n$$args.keys.forEach((key, index) => {\n  obj[key] = $$args.values[index];\n});\nreturn obj;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The new dictionary with the given keys and values."
    },
    "tests": {
      "buildObjectSimple": {
        "description": "Build a simple object from a list of keys and values.",
        "input": {
          "data": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "keys": ["a", "c"],
          "values": [4, 5]
        },
        "expected": {
          "a": 4,
          "c": 5
        }
      },
      "buildObjectMultipleKeys": {
        "description": "Build an object with multiple keys from a list of keys and values.",
        "input": {
          "data": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4,
            "e": 5
          },
          "keys": ["a", "c", "e"],
          "values": [6, 7, 8]
        },
        "expected": {
          "a": 6,
          "c": 7,
          "e": 8
        }
      }
    }
  },
  {
    "define": "_functions.String.CamelCase",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts a string to camelCase.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to convert to camelCase."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string\n  .toLowerCase()\n  .replace(/[^a-zA-Z0-9]+(.)/g, (match, chr) => chr.toUpperCase());\n"
      }
    },
    "returns": {
      "type": "String",
      "description": "The camelCased string."
    },
    "tests": {
      "camelCaseSingleWord": {
        "description": "Convert a single word to camelCase.",
        "input": {
          "string": "hello"
        },
        "expected": "hello"
      },
      "camelCaseMultipleWords": {
        "description": "Convert multiple words to camelCase.",
        "input": {
          "string": "hello world"
        },
        "expected": "helloWorld"
      },
      "camelCaseWithUnderscores": {
        "description": "Convert a string with underscores to camelCase.",
        "input": {
          "string": "hello_world_test"
        },
        "expected": "helloWorldTest"
      }
    }
  },
  {
    "define": "_functions.String.Capitalize",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Capitalizes the first letter of each word in a string.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to capitalize."
      }
    },
    "implementation": {
      "javascript": {
        "code": "console.log($$args);return $$args.string.replace(/\\b\\w/g, char => char.toUpperCase());\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The capitalized string."
    },
    "tests": {
      "capitalizeSingleWord": {
        "description": "Capitalize a single word.",
        "input": {
          "string": "hello"
        },
        "expected": "Hello"
      },
      "capitalizeMultipleWords": {
        "description": "Capitalize multiple words.",
        "input": {
          "string": "hello world"
        },
        "expected": "Hello World"
      },
      "capitalizeMixedCase": {
        "description": "Capitalize words in a mixed case string.",
        "input": {
          "string": "hElLo WoRlD"
        },
        "expected": "HElLo WoRlD"
      }
    }
  },
  {
    "define": "_functions.Math.Ceil",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Rounds a number up to the nearest integer.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The number to ceil."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.ceil($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The ceiling of the input value."
    },
    "tests": {
      "ceilZero": {
        "description": "Ceil the number 0.",
        "input": {
          "value": 0
        },
        "expected": 0
      },
      "ceilOnePointFive": {
        "description": "Ceil the number 1.5.",
        "input": {
          "value": 1.5
        },
        "expected": 2
      },
      "ceilNegativeTwo": {
        "description": "Ceil the negative number -2.4.",
        "input": {
          "value": -2.4
        },
        "expected": -2
      }
    }
  },
  {
    "define": "_functions.Math.Chunk",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Splits a list into chunks of a specified size.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The list to split into chunks.",
        "items": {
          "type": "_types.Unknown"
        }
      },
      "size": {
        "type": "_types.Number",
        "description": "The size of each chunk."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.size <= 0) {\n  throw new Error('Chunk size must be greater than 0');\n}\nconst result = [];\nfor (let i = 0; i < $$args.list.length; i += $$args.size) {\n  result.push($$args.list.slice(i, i + $$args.size));\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list of chunks.",
      "items": {
        "type": "_types.List",
        "items": {
          "type": "_types.Unknown"
        }
      }
    },
    "tests": {
      "chunkEqualSize": {
        "description": "Split a list into chunks of equal size.",
        "input": {
          "list": [1, 2, 3, 4, 5, 6],
          "size": 2
        },
        "expected": [
          [1, 2],
          [3, 4],
          [5, 6]
        ]
      },
      "chunkUnequalSize": {
        "description": "Split a list into chunks where the last chunk is smaller.",
        "input": {
          "list": [1, 2, 3, 4, 5],
          "size": 2
        },
        "expected": [[1, 2], [3, 4], [5]]
      },
      "chunkSizeOne": {
        "description": "Split a list into chunks of size one.",
        "input": {
          "list": [1, 2, 3],
          "size": 1
        },
        "expected": [[1], [2], [3]]
      },
      "chunkSizeGreaterThanList": {
        "description": "Split a list into chunks where the size is greater than the list length.",
        "input": {
          "list": [1, 2, 3],
          "size": 5
        },
        "expected": [[1, 2, 3]]
      }
    }
  },
  {
    "define": "_functions.Math.Compare",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Compare two numbers and return 1 if the first is greater, -1 if the second is greater, and 0 if they are equal.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number to compare."
      },
      "b": {
        "type": "_types.Number",
        "description": "The number to compare to."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.a > $$args.b) {\n  return 1;\n} else if ($$args.a < $$args.b) {\n  return -1;\n} else {\n  return 0;\n}\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "Returns 1 if a is greater than b, -1 if a is less than b, and 0 if they are equal."
    },
    "tests": {
      "compareTwo": {
        "description": "Compare two numbers.",
        "input": {
          "a": 1,
          "b": 2
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.String.Concatenate",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Concatenates an array of strings with a specified join string",
    "parameters": {
      "strings": {
        "type": "_types.List",
        "description": "The strings to concatenate"
      },
      "delimiter": {
        "type": "_types.String",
        "description": "The string to join the strings with"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.strings.join($$args.delimiter);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The concatenated string"
    },
    "tests": {
      "twoStrings": {
        "description": "Test with two strings",
        "input": {
          "strings": ["Hello", "World"],
          "delimiter": " "
        },
        "expected": "Hello World"
      },
      "customDelimiter": {
        "description": "Test with a custom delimiter",
        "input": {
          "strings": ["Hello", "World"],
          "delimiter": "-"
        },
        "expected": "Hello-World"
      }
    }
  },
  {
    "define": "_functions.String.Contains",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given text contains the specified pattern, false otherwise.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to search for the pattern."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The pattern to search for in the text."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.includes($$args.pattern);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the text contains the specified pattern."
    },
    "tests": {
      "containsTrue": {
        "description": "Text contains the pattern.",
        "input": {
          "text": "hello world",
          "pattern": "world"
        },
        "expected": true
      },
      "containsFalse": {
        "description": "Text does not contain the pattern.",
        "input": {
          "text": "hello world",
          "pattern": "universe"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.Cos",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the cosine of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the cosine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.cos($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The cosine of the angle."
    },
    "tests": {
      "cosZero": {
        "description": "Calculate the cosine of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 1
      },
      "cosPiOverTwo": {
        "description": "Calculate the cosine of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 6.123233995736766e-17
      },
      "cosPi": {
        "description": "Calculate the cosine of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.Math.Cosec",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the cosecant of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the cosecant of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function cosec(angle) {\n  const sinValue = Math.sin(angle);\n  if (sinValue === 0) {\n    throw new Error(\"Cosecant is undefined for angles where sine is zero.\");\n  }\n  return 1 / sinValue;\n}\nreturn cosec($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The cosecant of the angle."
    },
    "tests": {
      "cosecPiOverTwo": {
        "description": "Calculate the cosecant of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 1
      },
      "cosecPi": {
        "description": "Calculate the cosecant of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": 8165619676597685
      },
      "cosecThreePiOverTwo": {
        "description": "Calculate the cosecant of 3Ï€/2 radians.",
        "input": {
          "angle": 4.71238898038469
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.Math.Cosech",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the hyperbolic cosecant of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the hyperbolic cosecant of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function cosech(angle) {\n  const sinhValue = Math.sinh(angle);\n  if (sinhValue === 0) {\n    throw new Error(\"Cosech is undefined for angles where sinh is zero.\");\n  }\n  return 1 / sinhValue;\n}\nreturn cosech($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hyperbolic cosecant of the angle."
    },
    "tests": {
      "cosechOne": {
        "description": "Calculate the hyperbolic cosecant of 1 radian.",
        "input": {
          "angle": 1
        },
        "expected": 0.8509181282393216
      },
      "cosechNegativeOne": {
        "description": "Calculate the hyperbolic cosecant of -1 radian.",
        "input": {
          "angle": -1
        },
        "expected": -0.8509181282393216
      }
    }
  },
  {
    "define": "_functions.Math.Cosh",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the hyperbolic cosine of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the hyperbolic cosine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.cosh($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hyperbolic cosine of the angle."
    },
    "tests": {
      "coshZero": {
        "description": "Calculate the hyperbolic cosine of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 1
      },
      "coshPiOverTwo": {
        "description": "Calculate the hyperbolic cosine of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 2.5091784786580567
      },
      "coshPi": {
        "description": "Calculate the hyperbolic cosine of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": 11.591953275521519
      }
    }
  },
  {
    "define": "_functions.Math.Cot",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the cotangent of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the cotangent of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function cot(angle) {\n  const tanValue = Math.tan(angle);\n  if (tanValue === 0) {\n    throw new Error(\"Cotangent is undefined for angles where tangent is zero.\");\n  }\n  return 1 / tanValue;\n}\nreturn cot($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The cotangent of the angle."
    },
    "tests": {
      "cotPiOverFour": {
        "description": "Calculate the cotangent of Ï€/4 radians.",
        "input": {
          "angle": 0.7853981633974483
        },
        "expected": 1.0000000000000002
      },
      "cotThreePiOverFour": {
        "description": "Calculate the cotangent of 3Ï€/4 radians.",
        "input": {
          "angle": 2.356194490192345
        },
        "expected": -0.9999999999999998
      },
      "cotPi": {
        "description": "Calculate the cotangent of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": -8165619676597685
      }
    }
  },
  {
    "define": "_functions.Math.Coth",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the hyperbolic cotangent (coth) of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the hyperbolic coth of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function coth(angle) {\n  const sinhValue = Math.sinh(angle);\n  if (sinhValue === 0) {\n    throw new Error(\"Hyperbolic cotangent is undefined for angles where sinh is zero.\");\n  }\n  return Math.cosh(angle) / sinhValue;\n}\nreturn coth($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hyperbolic coth of the angle."
    },
    "tests": {
      "cothOne": {
        "description": "Calculate the hyperbolic coth of 1 radian.",
        "input": {
          "angle": 1
        },
        "expected": 1.3130352854993312
      },
      "cothNegativeOne": {
        "description": "Calculate the hyperbolic coth of -1 radian.",
        "input": {
          "angle": -1
        },
        "expected": -1.3130352854993312
      }
    }
  },
  {
    "define": "_functions.Logical.Count",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the count of elements in the given list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to count elements from."
      },
      "start": {
        "type": "_types.Number",
        "description": "Optional start index (0-based) for slicing. Default is 0."
      },
      "end": {
        "type": "_types.Number",
        "description": "Optional end index (0-based) for slicing. Negative index will be calculated from the end of the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function countElements(input, start, end) {\n  if (start === undefined) start = 0;\n  if (end === undefined) end = input.length;\n  if (end < 0) end = input.length + end;\n  return input.slice(start, end).length;\n}\nreturn countElements($$args.input, $$args.start, $$args.end);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The count of elements."
    },
    "tests": {
      "countSimple": {
        "description": "Count the number of items in a list.",
        "input": {
          "input": [1, 2, 3]
        },
        "expected": 3
      },
      "countSliceStart": {
        "description": "Count the number of items in a sliced list starting from index 0.",
        "input": {
          "input": [1, 2, 3],
          "end": 2
        },
        "expected": 2
      },
      "countSliceMiddle": {
        "description": "Count the number of items in a sliced list from index 1 to 2.",
        "input": {
          "input": [1, 2, 3],
          "start": 1,
          "end": 3
        },
        "expected": 2
      },
      "countSliceEndNegative": {
        "description": "Count the number of items in a sliced list with a negative end index.",
        "input": {
          "input": [1, 2, 3, 4],
          "start": 1,
          "end": -1
        },
        "expected": 2
      }
    }
  },
  {
    "define": "_functions.Math.Darken",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Darkens a color by decreasing its lightness.",
    "parameters": {
      "color": {
        "type": "_types.Dictionary",
        "description": "The color to darken, in HSL format."
      },
      "amount": {
        "type": "_types.Number",
        "description": "The amount to darken the color by (0-1.0)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function darken(color, amount) {\n  const newLightness = Math.max(color.l - amount, 0);\n  return { h: color.h, s: color.s, l: newLightness };\n}\n\nreturn darken($$args.color, $$args.amount);\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The darkened color in HSL format."
    },
    "tests": {
      "darkenSimple": {
        "description": "Darken a simple color.",
        "input": {
          "color": {
            "h": 120,
            "s": 1,
            "l": 0.5
          },
          "amount": 0.2
        },
        "expected": {
          "h": 120,
          "s": 1,
          "l": 0.3
        }
      },
      "darkenToMin": {
        "description": "Darken a color to the minimum lightness.",
        "input": {
          "color": {
            "h": 0,
            "s": 1,
            "l": 0.1
          },
          "amount": 0.2
        },
        "expected": {
          "h": 0,
          "s": 1,
          "l": 0
        }
      }
    }
  },
  {
    "define": "_functions.Date.Datetime",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a date-time object.",
    "parameters": {
      "value": {
        "type": "_types.Date",
        "description": "The input date-time value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.value instanceof Date) {\n  return $$args.value;\n} else if (typeof $$args.value === 'string') {\n  return new Date($$args.value).toString();\n} else {\n  throw new Error('Invalid input type');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Date",
      "description": "The date-time object."
    },
    "tests": {
      "datetimeValidString": {
        "description": "Test with a valid string date.",
        "input": {
          "value": "2022-01-01T12:00:00.000Z"
        },
        "expected": "Sat Jan 01 2022 12:00:00 GMT+0000 (Coordinated Universal Time)"
      },
      "datetimeInvalidString": {
        "description": "Test with an invalid string date.",
        "input": {
          "value": "abc"
        },
        "expected": "Invalid Date"
      },
      "datetimeValidDateObject": {
        "description": "Test with a valid Date object.",
        "input": {
          "value": "2022-01-01T12:00:00.000Z"
        },
        "expected": "Sat Jan 01 2022 12:00:00 GMT+0000 (Coordinated Universal Time)"
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeDifference",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the difference between two datetime values.",
    "parameters": {
      "start_date": {
        "type": "_types.Date",
        "description": "The starting date to calculate the difference from."
      },
      "end_date": {
        "type": "_types.Date",
        "description": "The ending date to calculate the difference up to."
      },
      "unit": {
        "type": "_types.String",
        "enum": ["days", "hours", "minutes"],
        "description": "The unit of the calculated difference."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const diff = $$args.end_date.getTime() - $$args.start_date.getTime();\nif ($$args.unit == \"days\") {\n  return new Date(diff / (1000 * 60 * 60 * 24)).getDate();\n} else if ($$args.unit == \"hours\") {\n  return Math.floor(diff / (1000 * 60 * 60));\n} else if ($$args.unit == \"minutes\") {\n  return Math.floor(diff / (1000 * 60));\n}\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The calculated difference in the specified unit."
    },
    "tests": {
      "datetimeDifferenceDays": {
        "description": "Calculate the difference between two dates in days.",
        "input": {
          "start_date": "2022-01-01T00:00:00.000Z",
          "end_date": "2022-01-03T12:00:00.000Z",
          "unit": "days"
        },
        "expected": 1
      },
      "datetimeDifferenceHours": {
        "description": "Calculate the difference between two dates in hours.",
        "input": {
          "start_date": "2022-01-01T10:30:00.000Z",
          "end_date": "2022-01-02T14:45:00.000Z",
          "unit": "hours"
        },
        "expected": 28
      },
      "datetimeDifferenceMinutes": {
        "description": "Calculate the difference between two dates in minutes.",
        "input": {
          "start_date": "2022-01-01T10:30:00.000Z",
          "end_date": "2022-01-02T11:15:00.000Z",
          "unit": "minutes"
        },
        "expected": 1485
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsAfter",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Compares two dates and returns a boolean indicating if the first date is after the second.",
    "parameters": {
      "date1": {
        "type": "_types.Date",
        "description": "The first date to compare in ISO format."
      },
      "date2": {
        "type": "_types.Date",
        "description": "The second date to compare in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const date1 = new Date($$args.date1);\nconst date2 = new Date($$args.date2);\nreturn date1.getTime() > date2.getTime();\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the first date is after the second."
    },
    "tests": {
      "datetimeIsAfterToday": {
        "description": "Check if a date in the future is after today.",
        "input": {
          "date1": "2023-01-01T12:00:00.000Z",
          "date2": "2022-01-01T12:00:00.000Z"
        },
        "expected": true
      },
      "datetimeIsNotAfterToday": {
        "description": "Check if a date in the past is not after today.",
        "input": {
          "date1": "2020-01-01T12:00:00.000Z",
          "date2": "2022-01-01T12:00:00.000Z"
        },
        "expected": false
      },
      "datetimeIsEqual": {
        "description": "Check if two dates that are the same return false.",
        "input": {
          "date1": "2022-01-01T12:00:00.000Z",
          "date2": "2022-01-01T12:00:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsBefore",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Compares two datetime values and returns true if the first datetime is before the second.",
    "parameters": {
      "datetime1": {
        "type": "_types.Date",
        "description": "The first datetime to compare in ISO format."
      },
      "datetime2": {
        "type": "_types.Date",
        "description": "The second datetime to compare in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const datetime1 = new Date($$args.datetime1);\nconst datetime2 = new Date($$args.datetime2);\nreturn datetime1.getTime() < datetime2.getTime();\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the first datetime is before the second, false otherwise."
    },
    "tests": {
      "datetimeIsBeforeSameDate": {
        "description": "Compare two dates on the same day.",
        "input": {
          "datetime1": "2023-03-15T14:30:00.000Z",
          "datetime2": "2023-03-15T16:30:00.000Z"
        },
        "expected": true
      },
      "datetimeIsBeforeEarlierDate": {
        "description": "Compare two dates on different days, but the first is earlier.",
        "input": {
          "datetime1": "2023-03-14T14:30:00.000Z",
          "datetime2": "2023-03-15T16:30:00.000Z"
        },
        "expected": true
      },
      "datetimeIsBeforeLaterDate": {
        "description": "Compare two dates on different days, but the first is later.",
        "input": {
          "datetime1": "2023-03-16T14:30:00.000Z",
          "datetime2": "2023-03-15T16:30:00.000Z"
        },
        "expected": false
      },
      "datetimeIsEqual": {
        "description": "Compare two identical dates.",
        "input": {
          "datetime1": "2023-03-15T16:30:00.000Z",
          "datetime2": "2023-03-15T16:30:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsBetween",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a date is between two dates.",
    "parameters": {
      "datetime": {
        "type": "_types.Date",
        "description": "The date to check in ISO format."
      },
      "start": {
        "type": "_types.Date",
        "description": "The start date of the range in ISO format."
      },
      "end": {
        "type": "_types.Date",
        "description": "The end date of the range in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const datetime = new Date($$args.datetime);\nconst start = new Date($$args.start);\nconst end = new Date($$args.end);\nreturn datetime >= start && datetime <= end;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the datetime is between the start and end dates."
    },
    "tests": {
      "datetimeIsBetweenSimple": {
        "description": "Check a date within the range.",
        "input": {
          "datetime": "2022-01-01T00:00:00.000Z",
          "start": "2022-01-01T00:00:00.000Z",
          "end": "2022-01-31T23:59:59.999Z"
        },
        "expected": true
      },
      "datetimeIsBetweenStart": {
        "description": "Check a date at the start of the range.",
        "input": {
          "datetime": "2022-01-01T00:00:00.000Z",
          "start": "2022-01-01T00:00:00.000Z",
          "end": "2022-01-31T23:59:59.999Z"
        },
        "expected": true
      },
      "datetimeIsBetweenEnd": {
        "description": "Check a date at the end of the range.",
        "input": {
          "datetime": "2022-01-31T23:59:59.999Z",
          "start": "2022-01-01T00:00:00.000Z",
          "end": "2022-01-31T23:59:59.999Z"
        },
        "expected": true
      },
      "datetimeIsOutsideRange": {
        "description": "Check a date outside the range.",
        "input": {
          "datetime": "2021-12-31T23:59:59.999Z",
          "start": "2022-01-01T00:00:00.000Z",
          "end": "2022-01-31T23:59:59.999Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsSame",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if two datetime values are the same.",
    "parameters": {
      "date1": {
        "type": "_types.Date",
        "description": "The first datetime value to compare in ISO format."
      },
      "date2": {
        "type": "_types.Date",
        "description": "The second datetime value to compare in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const date1 = new Date($$args.date1);\nconst date2 = new Date($$args.date2);\nreturn date1.getTime() === date2.getTime();\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the two datetime values are the same or not."
    },
    "tests": {
      "datetimeIsSameSame": {
        "description": "Compare two identical datetime values.",
        "input": {
          "date1": "2020-01-01T00:00:00.000Z",
          "date2": "2020-01-01T00:00:00.000Z"
        },
        "expected": true
      },
      "datetimeIsSameDifferent": {
        "description": "Compare two different datetime values.",
        "input": {
          "date1": "2020-01-01T00:00:00.000Z",
          "date2": "2020-02-01T00:00:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsSameOrAfter",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Compares two dates and returns true if the given date is same or after the reference date.",
    "parameters": {
      "referenceDate": {
        "type": "_types.Date",
        "description": "The reference date to compare with in ISO format."
      },
      "targetDate": {
        "type": "_types.Date",
        "description": "The target date to compare in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const referenceDate = new Date($$args.referenceDate);\nconst targetDate = new Date($$args.targetDate);\nreturn targetDate.getTime() >= referenceDate.getTime();\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the target date is same or after the reference date."
    },
    "tests": {
      "datetimeIsSameOrAfterSame": {
        "description": "Compare two dates that are the same.",
        "input": {
          "referenceDate": "2022-01-01T00:00:00.000Z",
          "targetDate": "2022-01-01T00:00:00.000Z"
        },
        "expected": true
      },
      "datetimeIsSameOrAfterAfter": {
        "description": "Compare two dates where the target date is after the reference date.",
        "input": {
          "referenceDate": "2022-01-01T00:00:00.000Z",
          "targetDate": "2022-02-01T00:00:00.000Z"
        },
        "expected": true
      },
      "datetimeIsSameOrAfterBefore": {
        "description": "Compare two dates where the target date is before the reference date.",
        "input": {
          "referenceDate": "2022-02-01T00:00:00.000Z",
          "targetDate": "2022-01-01T00:00:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.DatetimeIsSameOrBefore",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a given date is the same or before another given date.",
    "parameters": {
      "date1": {
        "type": "_types.Date",
        "description": "The date to compare."
      },
      "date2": {
        "type": "_types.Date",
        "description": "The date against which to compare."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.date1 <= $$args.date2;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the given date is the same or before another given date."
    },
    "tests": {
      "sameDate": {
        "description": "Compare two dates that are the same.",
        "input": {
          "date1": "2020-01-01T00:00:00.000Z",
          "date2": "2020-01-01T00:00:00.000Z"
        },
        "expected": true
      },
      "beforeDate": {
        "description": "Compare two dates where one is before the other.",
        "input": {
          "date1": "2019-12-31T23:59:59.999Z",
          "date2": "2020-01-01T00:00:00.000Z"
        },
        "expected": true
      },
      "sameDateButTime": {
        "description": "Compare two dates that are the same but have different times.",
        "input": {
          "date1": "2020-01-01T23:59:59.999Z",
          "date2": "2020-01-01T00:00:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.String.DefaultString",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the default string value for a given input.",
    "parameters": {
      "input": {
        "type": "_types.String",
        "description": "The input to check for a default value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.input == null || $$args.input === \"\") {\n  return \"default\";\n} else {\n  return $$args.input;\n}\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The default string value or the input value if it is not null or an empty string."
    },
    "tests": {
      "defaultStringNull": {
        "description": "Check for a null input.",
        "input": {
          "input": null
        },
        "expected": "default"
      },
      "defaultStringEmptyString": {
        "description": "Check for an empty string as input.",
        "input": {
          "input": ""
        },
        "expected": "default"
      },
      "defaultStringNonDefaultInput": {
        "description": "Check for a non-default input.",
        "input": {
          "input": "hello"
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.String.DefaultFileExtension",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the default file extension for a given type.",
    "parameters": {
      "type": {
        "type": "_types.String",
        "description": "The type of file to determine the default extension for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const extensions = {\n  'image': '.png',\n  'video': '.mp4',\n  // Add more types and their default extensions as needed\n};\nreturn extensions[$$args.type] || '';\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The default file extension for the given type."
    },
    "tests": {
      "defaultFileExtensionImage": {
        "description": "Get the default file extension for an image.",
        "input": {
          "type": "image"
        },
        "expected": ".png"
      },
      "defaultFileExtensionVideo": {
        "description": "Get the default file extension for a video.",
        "input": {
          "type": "video"
        },
        "expected": ".mp4"
      },
      "defaultFileExtensionUnknown": {
        "description": "Get the default file extension for an unknown type.",
        "input": {
          "type": "unknown"
        },
        "expected": ""
      }
    }
  },
  {
    "define": "_functions.Dictionary.DeleteKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes the specified key-value pair from a dictionary.",
    "parameters": {
      "dictionary": {
        "type": "_types.Dictionary",
        "description": "The dictionary to remove the key-value pair from."
      },
      "key": {
        "type": "_types.String",
        "description": "The key of the key-value pair to delete."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.dictionary.hasOwnProperty($$args.key)) {\n  delete $$args.dictionary[$$args.key];\n}\nreturn $$args.dictionary;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The dictionary with the specified key-value pair removed."
    },
    "tests": {
      "deleteKeyNonExistingKey": {
        "description": "Attempt to delete a key that does not exist in the dictionary.",
        "input": {
          "dictionary": {
            "a": 1,
            "b": 2
          },
          "key": "c"
        },
        "expected": {
          "a": 1,
          "b": 2
        }
      }
    }
  },
  {
    "define": "_functions.List.Difference",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the elements that are in one list but not in another.",
    "parameters": {
      "list1": {
        "type": "_types.List",
        "description": "The first list.",
        "items": {
          "type": "_types.Any"
        }
      },
      "list2": {
        "type": "_types.List",
        "description": "The second list.",
        "items": {
          "type": "_types.Any"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "const set2 = new Set($$args.list2);\nreturn $$args.list1.filter(item => !set2.has(item));\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list of elements that are in the first list but not in the second list.",
      "items": {
        "type": "_types.Any"
      }
    },
    "tests": {
      "differenceNoOverlap": {
        "description": "Difference of two lists with no overlap.",
        "input": {
          "list1": [1, 2, 3],
          "list2": [4, 5, 6]
        },
        "expected": [1, 2, 3]
      },
      "differenceWithOverlap": {
        "description": "Difference of two lists with some overlap.",
        "input": {
          "list1": [1, 2, 3, 4],
          "list2": [3, 4, 5, 6]
        },
        "expected": [1, 2]
      },
      "differenceEmptyFirstList": {
        "description": "Difference with an empty first list.",
        "input": {
          "list1": [],
          "list2": [1, 2, 3]
        },
        "expected": []
      },
      "differenceEmptySecondList": {
        "description": "Difference with an empty second list.",
        "input": {
          "list1": [1, 2, 3],
          "list2": []
        },
        "expected": [1, 2, 3]
      },
      "differenceBothEmpty": {
        "description": "Difference of two empty lists.",
        "input": {
          "list1": [],
          "list2": []
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.List.Div",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Splits the list into sublists of a specified size.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to be divided."
      },
      "size": {
        "type": "_types.Number",
        "description": "The size of each sublist."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = [];\nfor (let i = 0; i < $$args.input.length; i += $$args.size) {\n  result.push($$args.input.slice(i, i + $$args.size));\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The divided list."
    },
    "tests": {
      "divSimple": {
        "description": "Divide a list of three items into sublists of size one.",
        "input": {
          "input": ["a", "b", "c"],
          "size": 1
        },
        "expected": [["a"], ["b"], ["c"]]
      },
      "divMultiple": {
        "description": "Divide a list of five items into sublists of size two.",
        "input": {
          "input": ["a", "b", "c", "d", "e"],
          "size": 2
        },
        "expected": [["a", "b"], ["c", "d"], ["e"]]
      },
      "divLastElement": {
        "description": "Divide a list with one element into sublists of size two.",
        "input": {
          "input": ["a"],
          "size": 2
        },
        "expected": [["a"]]
      }
    }
  },
  {
    "define": "_functions.Math.Divide",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Divide two numbers.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a / $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The quotient of the two numbers."
    },
    "tests": {
      "divideTwo": {
        "description": "Divide two numbers.",
        "input": {
          "a": 6,
          "b": 2
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.String.EncodeForUrl",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Encodes a string for use in URLs.",
    "parameters": {
      "input": {
        "type": "_types.String",
        "description": "The input string to encode."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return encodeURIComponent($$args.input);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The encoded string."
    },
    "tests": {
      "encodeForUrlSimple": {
        "description": "Encode a simple string.",
        "input": {
          "input": "hello world"
        },
        "expected": "hello%20world"
      },
      "encodeForUrlSpecialChars": {
        "description": "Encode strings with special characters.",
        "input": {
          "input": "http://example.com/search?q=foo+bar"
        },
        "expected": "http%3A%2F%2Fexample.com%2Fsearch%3Fq%3Dfoo%2Bbar"
      },
      "encodeForUrlEmptyString": {
        "description": "Encode an empty string.",
        "input": {
          "input": ""
        },
        "expected": ""
      }
    }
  },
  {
    "define": "_functions.Any.EncodeJSON",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Encodes a given input as JSON.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The input to be encoded as JSON."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return JSON.stringify($$args.input);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The JSON-encoded input."
    },
    "tests": {
      "encodeJSONSimple": {
        "description": "Encode a simple object.",
        "input": {
          "input": {
            "key": "value"
          }
        },
        "expected": "{\"key\":\"value\"}"
      },
      "encodeJSONComplex": {
        "description": "Encode a complex object.",
        "input": {
          "input": {
            "a": [1, 2, 3],
            "b": {
              "x": 5,
              "y": 6
            }
          }
        },
        "expected": "{\"a\":[1,2,3],\"b\":{\"x\":5,\"y\":6}}"
      },
      "encodeJSONNull": {
        "description": "Encode null as JSON.",
        "input": {
          "input": null
        },
        "expected": "null"
      }
    }
  },
  {
    "define": "_functions.Math.Euler",
    "blueprint": "_blueprint.Flowgraph",
    "description": "The Euler's totient function, also known as Euler's phi function, is a fundamental arithmetic function in number theory.",
    "parameters": {
      "n": {
        "type": "_types.Number",
        "description": "The input number for which to calculate the Euler's totient function value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function gcd(a, b) {\n  while (b !== 0) {\n    const temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n\nfunction eulerTotient(n) {\n  let result = n;\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      while (n % i === 0) {\n        n /= i;\n      }\n      result -= result / i;\n    }\n  }\n\n  if (n > 1) {\n    result -= result / n;\n  }\n\n  return result;\n}\n\nreturn eulerTotient($$args.n);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The Euler's totient function value for the given input number."
    },
    "tests": {
      "eulerSimple": {
        "description": "Calculate the Euler's totient function for a simple case.",
        "input": {
          "n": 10
        },
        "expected": 4
      },
      "eulerMedium": {
        "description": "Calculate the Euler's totient function for a medium-sized case.",
        "input": {
          "n": 1000
        },
        "expected": 400
      }
    }
  },
  {
    "define": "_functions.Math.Even",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns whether the given number is even.",
    "parameters": {
      "input": {
        "type": "_types.Number",
        "description": "The number to check if it's even."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input % 2 === 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the number is even or not."
    },
    "tests": {
      "evenZero": {
        "description": "Check if 0 is even.",
        "input": {
          "input": 0
        },
        "expected": true
      },
      "evenPositive": {
        "description": "Check if a positive number is even.",
        "input": {
          "input": 4
        },
        "expected": true
      },
      "evenNegative": {
        "description": "Check if a negative number is even.",
        "input": {
          "input": -2
        },
        "expected": true
      },
      "oddPositive": {
        "description": "Check if an odd number is not even.",
        "input": {
          "input": 3
        },
        "expected": false
      },
      "oddNegative": {
        "description": "Check if an odd negative number is not even.",
        "input": {
          "input": -1
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Dictionary.ExcludeByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Excludes items in the dictionary based on their keys.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The dictionary to exclude items from."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to exclude."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = {};\nfor (const [k, v] of Object.entries($$args.input)) {\n  if (k !== $$args.key) {\n    result[k] = v;\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "A new dictionary with items that do not have the specified key."
    },
    "tests": {
      "excludeByKeyPresent": {
        "description": "Exclude items with the key present in some items.",
        "input": {
          "input": {
            "a": 1,
            "b": 2
          },
          "key": "a"
        },
        "expected": {
          "b": 2
        }
      },
      "excludeByKeyNotPresent": {
        "description": "Exclude items when no items have the specified key.",
        "input": {
          "input": {
            "x": 3,
            "y": 4
          },
          "key": "z"
        },
        "expected": {
          "x": 3,
          "y": 4
        }
      },
      "excludeByKeyMixed": {
        "description": "Exclude items with a mix of presence and absence of the key.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 4
          },
          "key": "a"
        },
        "expected": {
          "b": 2,
          "c": 4
        }
      }
    }
  },
  {
    "define": "_functions.List.ExcludeByRegex",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list that excludes the elements that match the given regular expression.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to exclude elements from."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The regular expression pattern to match and exclude."
      },
      "replacement": {
        "type": "_types.Any",
        "description": "This parameter is ignored in this function. It's kept for consistency with other functions."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = new RegExp($$args.pattern);\nreturn $$args.input.filter((item) => !regex.test(item));\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list of elements that do not match the regular expression pattern."
    },
    "tests": {
      "excludeByRegexSimple": {
        "description": "Exclude a simple match.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "pattern": "c"
        },
        "expected": ["a", "b", "d"]
      },
      "excludeByRegexFirstMatch": {
        "description": "Exclude only the first match of the pattern.",
        "input": {
          "input": ["one", "two", "three", "four"],
          "pattern": "two"
        },
        "expected": ["one", "three", "four"]
      },
      "excludeByRegexNoMatch": {
        "description": "Attempt to exclude when no match is found.",
        "input": {
          "input": ["hello", "world", "foo", "bar"],
          "pattern": "baz"
        },
        "expected": ["hello", "world", "foo", "bar"]
      }
    }
  },
  {
    "define": "_functions.Math.Factorial",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the factorial of a given number.",
    "parameters": {
      "n": {
        "type": "_types.Number",
        "description": "The number to calculate the factorial of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function fact(n) {\n  if (n < 0) throw new Error(\"Factorial is not defined for negative numbers\");\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\nreturn fact($$args.n);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The factorial of the given number."
    },
    "tests": {
      "factorialOne": {
        "description": "Calculate the factorial of 1.",
        "input": {
          "n": 1
        },
        "expected": 1
      },
      "factorialTwo": {
        "description": "Calculate the factorial of 2.",
        "input": {
          "n": 2
        },
        "expected": 2
      },
      "factorialThree": {
        "description": "Calculate the factorial of 3.",
        "input": {
          "n": 3
        },
        "expected": 6
      }
    }
  },
  {
    "define": "_functions.Math.FadeIn",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the fade-in value based on the given start and end values.",
    "parameters": {
      "start": {
        "type": "_types.Number",
        "description": "The starting value for the fade-in."
      },
      "end": {
        "type": "_types.Number",
        "description": "The ending value for the fade-in."
      },
      "t": {
        "type": "_types.Number",
        "description": "The position within the fade, ranging from 0 to 1."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.start + ($$args.end - $$args.start) * $$args.t;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The fade-in value based on the start, end values, and position t."
    },
    "tests": {
      "fadeInSimple": {
        "description": "Calculate a simple fade-in.",
        "input": {
          "start": 0,
          "end": 10,
          "t": 1
        },
        "expected": 10
      },
      "fadeInReverse": {
        "description": "Calculate a reverse fade-in.",
        "input": {
          "start": 10,
          "end": 0,
          "t": 1
        },
        "expected": 0
      },
      "fadeInMid": {
        "description": "Calculate a fade-in to the midpoint.",
        "input": {
          "start": 0,
          "end": 10,
          "t": 0.5
        },
        "expected": 5
      }
    }
  },
  {
    "define": "_functions.Math.FadeOut",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Fades out the input number to zero.",
    "parameters": {
      "startValue": {
        "type": "_types.Number",
        "description": "The initial value of the number to fade out."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const duration = 1.0;\nlet current = $$args.startValue;\nfor (let i = 0; i < duration * 60; i++) {\n  if (current <= 0) return 0;\n  current -= $$args.startValue / duration;\n}\nreturn 0;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The faded out value."
    },
    "tests": {
      "fadeOutSimple": {
        "description": "Fade out a simple number.",
        "input": {
          "startValue": 10
        },
        "expected": 0
      },
      "fadeOutComplex": {
        "description": "Fade out a complex number.",
        "input": {
          "startValue": 5.2
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Math.FilenameIsImage",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Determines whether a file name is an image.",
    "parameters": {
      "filename": {
        "type": "_types.String",
        "description": "The file name to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const extensions = [\".png\", \".jpg\", \".jpeg\", \".gif\"];\nreturn extensions.some(extension => $$args.filename.endsWith(extension));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the file name is an image or not."
    },
    "tests": {
      "filenameIsImageSimple": {
        "description": "Check a simple image file.",
        "input": {
          "filename": "image.jpg"
        },
        "expected": true
      },
      "filenameIsImageNotImage": {
        "description": "Check a non-image file.",
        "input": {
          "filename": "document.txt"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Dictionary.FindByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Finds the value in a dictionary that corresponds to the given key.",
    "parameters": {
      "dictionary": {
        "type": "_types.Dictionary",
        "description": "The dictionary to search."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to find the value for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.dictionary[$$args.key];\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The value associated with the given key, or undefined if not found."
    },
    "tests": {
      "findByKeySimple": {
        "description": "Find a simple value.",
        "input": {
          "dictionary": {
            "foo": "bar",
            "baz": "qux"
          },
          "key": "foo"
        },
        "expected": "bar"
      },
      "findByKeyNonExistingKey": {
        "description": "Attempt to find a non-existent key.",
        "input": {
          "dictionary": {
            "foo": "bar",
            "baz": "qux"
          },
          "key": "notfound"
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.String.FindByRegex",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Finds the first match of a regular expression in a given text.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to search for matches."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The regular expression pattern to find."
      },
      "group": {
        "type": "_types.Any",
        "description": "The group number to return the match from (optional)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = new RegExp($$args.pattern);\nconst match = $$args.text.match(regex);\nif (!match) return null;\nif ($$args.group !== undefined) {\n  return match[$$args.group] || null;\n} else {\n  return match[0];\n}\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The first match of the regular expression."
    },
    "tests": {
      "findByRegexSimple": {
        "description": "Find the first match of a simple pattern.",
        "input": {
          "text": "hello world",
          "pattern": "world"
        },
        "expected": "world"
      },
      "findByRegexGroup": {
        "description": "Find the first match of a pattern and return the group.",
        "input": {
          "text": "hello john smith",
          "pattern": "(\\w+) (\\w+)",
          "group": 1
        },
        "expected": "hello"
      },
      "findByRegexNoMatch": {
        "description": "Attempt to find when no match is found.",
        "input": {
          "text": "hello world",
          "pattern": "foo"
        },
        "expected": null
      },
      "findByRegexNamedGroup": {
        "description": "Find the first match of a pattern with a named group.",
        "input": {
          "text": "hello john smith",
          "pattern": "(?<first>\\w+) (?<last>\\w+)",
          "group": "groups.first"
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.List.FirstItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the first item of a given list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to get the first item from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input[0];\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The first item in the list, or undefined if the list is empty."
    },
    "tests": {
      "firstItemSimple": {
        "description": "Get the first item of a simple list.",
        "input": {
          "input": ["a", "b", "c"]
        },
        "expected": "a"
      },
      "firstItemEmptyList": {
        "description": "Attempt to get the first item from an empty list.",
        "input": {
          "input": []
        },
        "expected": null
      },
      "firstItemNumberList": {
        "description": "Get the first item of a list of numbers.",
        "input": {
          "input": [1, 2, 3]
        },
        "expected": 1
      },
      "firstItemMixedList": {
        "description": "Get the first item of a list with mixed types.",
        "input": {
          "input": [true, "b", 3]
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.List.Flatten",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Flattens a nested list into a single list.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The nested list to flatten.",
        "items": {
          "type": "_types.Unknown"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "const flatten = (arr) => arr.reduce((flat, toFlatten) => \n  flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten), []);\nreturn flatten($$args.list);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The flattened list.",
      "items": {
        "type": "_types.Unknown"
      }
    },
    "tests": {
      "flattenSimple": {
        "description": "Flatten a simple nested list.",
        "input": {
          "list": [
            [1, 2],
            [3, 4]
          ]
        },
        "expected": [1, 2, 3, 4]
      },
      "flattenComplex": {
        "description": "Flatten a complex nested list.",
        "input": {
          "list": [1, [2, [3, [4]]]]
        },
        "expected": [1, 2, 3, 4]
      },
      "flattenEmptyList": {
        "description": "Flatten an empty list.",
        "input": {
          "list": []
        },
        "expected": []
      },
      "flattenAlreadyFlat": {
        "description": "Flatten an already flat list.",
        "input": {
          "list": [1, 2, 3, 4]
        },
        "expected": [1, 2, 3, 4]
      }
    }
  },
  {
    "define": "_functions.Math.Floor",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Rounds a number down to the nearest integer.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The number to round down."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.floor($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The rounded down value."
    },
    "tests": {
      "floorZero": {
        "description": "Round 0 down.",
        "input": {
          "value": 0
        },
        "expected": 0
      },
      "floorPositive": {
        "description": "Round a positive number down.",
        "input": {
          "value": 3.5
        },
        "expected": 3
      },
      "floorNegative": {
        "description": "Round a negative number down.",
        "input": {
          "value": -4.7
        },
        "expected": -5
      }
    }
  },
  {
    "define": "_functions.Math.FormatDatetimeLocal",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Formats a date and time according to the given pattern.",
    "parameters": {
      "datetime": {
        "type": "_types.String",
        "description": "The date and time to format."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The pattern to use for formatting the date and time."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const dt = new Date($$args.datetime);\nreturn dt.toLocaleString();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The formatted date and time."
    },
    "tests": {
      "formatDatetimeLocalSimple": {
        "description": "Format a simple date.",
        "input": {
          "datetime": "2022-01-01T12:00:00.000Z",
          "pattern": ""
        },
        "expected": "1/1/2022, 12:00:00 PM"
      },
      "formatDatetimeLocalComplex": {
        "description": "Format a complex date with timezone.",
        "input": {
          "datetime": "2022-01-01T12:00:00.000+02:00",
          "pattern": ""
        },
        "expected": "1/1/2022, 10:00:00 AM"
      }
    }
  },
  {
    "define": "_functions.String.FormatDatetimeWithTimezone",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Formats a date and time string with the given timezone.",
    "parameters": {
      "datetime": {
        "type": "_types.String",
        "description": "The date and time string to format."
      },
      "timezone": {
        "type": "_types.String",
        "description": "The timezone to apply to the datetime."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const dt = new Date($$args.datetime);\nreturn dt.toLocaleString('en-US', { timeZone: $$args.timezone });\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The formatted date and time string with the given timezone."
    },
    "tests": {
      "formatDatetimeWithTimezoneSimple": {
        "description": "Format a simple datetime.",
        "input": {
          "datetime": "2022-01-01T00:00:00Z",
          "timezone": "America/New_York"
        },
        "expected": "12/31/2021, 7:00:00 PM"
      },
      "formatDatetimeWithTimezoneNoZoneOffset": {
        "description": "Format a datetime with no zone offset.",
        "input": {
          "datetime": "2022-01-01T00:00:00+02:00",
          "timezone": "Etc/GMT-1"
        },
        "expected": "12/31/2021, 11:00:00 PM"
      }
    }
  },
  {
    "define": "_functions.Math.GenerateRange",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Generates a list of numbers starting from the given Start and ending at the given End.",
    "parameters": {
      "start": {
        "type": "_types.Number",
        "description": "The starting number."
      },
      "end": {
        "type": "_types.Number",
        "description": "The ending number. If the end is a negative index, it will generate a range up to that negative value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = [];\nif ($$args.end < 0) {\n  for (let i = $$args.start; i >= $$args.end; i--) {\n    result.push(i);\n  }\n} else {\n  for (let i = $$args.start; i <= $$args.end; i++) {\n    result.push(i);\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A list of numbers from start to end."
    },
    "tests": {
      "generateRangeSimple": {
        "description": "Generate a range with positive indices.",
        "input": {
          "start": 0,
          "end": 5
        },
        "expected": [0, 1, 2, 3, 4, 5]
      },
      "generateRangeNegativeEnd": {
        "description": "Generate a range with negative end value.",
        "input": {
          "start": 1,
          "end": -2
        },
        "expected": [1, 0, -1, -2]
      },
      "generateRangeStartAndEndEqual": {
        "description": "Generate a range where start and end are equal.",
        "input": {
          "start": 5,
          "end": 5
        },
        "expected": [5]
      }
    }
  },
  {
    "define": "_functions.String.GenerateUUID",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Generates a unique identifier (UUID).",
    "parameters": {},
    "implementation": {
      "javascript": {
        "code": "return crypto.randomUUID();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The generated UUID."
    },
    "tests": null
  },
  {
    "define": "_functions.Date.GetDatetimeComponent",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the specified component of a datetime.",
    "parameters": {
      "datetime": {
        "type": "_types.String",
        "description": "The datetime to get the component from in ISO format."
      },
      "component": {
        "type": "_types.String",
        "description": "The desired component (year, month, day, hour, minute, second)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let value = new Date($$args.datetime);\nswitch ($$args.component) {\n  case 'year':\n    return value.getFullYear();\n  case 'month':\n    return value.getMonth() + 1; // months are 0-based in JS\n  case 'day':\n    return value.getDate();\n  case 'hour':\n    return value.getUTCHours();\n  case 'minute':\n    return value.getUTCMinutes();\n  case 'second':\n    return value.getUTCSeconds();\n  default:\n    throw new Error('Invalid component');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The specified component of the datetime."
    },
    "tests": {
      "getDatetimeYear": {
        "description": "Get the year component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "year"
        },
        "expected": 2022
      },
      "getDatetimeMonth": {
        "description": "Get the month component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "month"
        },
        "expected": 7
      },
      "getDatetimeDay": {
        "description": "Get the day component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "day"
        },
        "expected": 25
      },
      "getDatetimeHour": {
        "description": "Get the hour component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "hour"
        },
        "expected": 14
      },
      "getDatetimeMinute": {
        "description": "Get the minute component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "minute"
        },
        "expected": 30
      },
      "getDatetimeSecond": {
        "description": "Get the second component.",
        "input": {
          "datetime": "2022-07-25T14:30:00.000Z",
          "component": "second"
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Dictionary.GetKeys",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the keys of an object.",
    "parameters": {
      "object": {
        "type": "_types.Dictionary",
        "description": "The object to get the keys of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Object.keys($$args.object);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The keys of the object."
    },
    "tests": {
      "twoKeys": {
        "description": "Test with an object with two keys.",
        "input": {
          "object": {
            "a": 1,
            "b": 2
          }
        },
        "expected": ["a", "b"]
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "object": {}
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.Number.IsGreaterThan",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Check if a number is greater than another number.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number to be compared."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number to be compared."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a > $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Returns true if a is greater than b, and false otherwise."
    },
    "tests": {
      "greaterThanTest": {
        "description": "Check if a number is greater than another number.",
        "input": {
          "a": 5,
          "b": 2
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.GreaterThanOrEqual",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Check if a number is greater than or equal to another number.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number to be compared."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number to be compared."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a >= $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Returns true if a is greater than or equal to b, and false otherwise."
    },
    "tests": {
      "greaterThanOrEqualTest": {
        "description": "Check if a number is greater than or equal to another number.",
        "input": {
          "a": 5,
          "b": 2
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.GreatestCommonDivisor",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the greatest common divisor of two numbers.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function gcd(a, b) {\n  if (b === 0) return a;\n  return gcd(b, a % b);\n}\nreturn gcd($$args.a, $$args.b);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The greatest common divisor."
    },
    "tests": {
      "gcdSimple": {
        "description": "Calculate the GCD of two simple numbers.",
        "input": {
          "a": 12,
          "b": 15
        },
        "expected": 3
      },
      "gcdPrime": {
        "description": "Calculate the GCD of two prime numbers.",
        "input": {
          "a": 23,
          "b": 37
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.String.Green",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the result of a given input.",
    "parameters": {
      "input": {
        "type": "_types.String",
        "description": "The value to get the green color code from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return `#34C759`\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The green color code in hexadecimal format."
    },
    "tests": {
      "greenColorCode": {
        "description": "Get the green color code.",
        "input": {
          "input": null
        },
        "expected": "#34C759"
      },
      "greenColorCodeWithInput": {
        "description": "Get the green color code with an input value.",
        "input": {
          "input": "Hello, World!"
        },
        "expected": "#34C759"
      }
    }
  },
  {
    "define": "_functions.Math.HSL",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts Hue, Saturation, and Lightness values into an RGB color.",
    "parameters": {
      "hue": {
        "type": "_types.Number",
        "description": "The hue value (0-360 degrees)."
      },
      "saturation": {
        "type": "_types.Number",
        "description": "The saturation value (0-1.0)."
      },
      "lightness": {
        "type": "_types.Number",
        "description": "The lightness value (0-1.0)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hslToRgb(h, s, l) {\n  h = h / 360;\n  let r, g, b;\n\n  if (s == 0) {\n    r = g = b = l;\n  } else {\n    const hue2rgb = function(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n}\n\nreturn hslToRgb($$args.hue, $$args.saturation, $$args.lightness);\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The RGB color."
    },
    "tests": {
      "hslToRgbSimple": {
        "description": "Convert a simple HSL to RGB.",
        "input": {
          "hue": 0,
          "saturation": 1,
          "lightness": 0.5
        },
        "expected": {
          "r": 255,
          "g": 0,
          "b": 0
        }
      },
      "hslToRgbDifferentSaturation": {
        "description": "Convert HSL with different saturation.",
        "input": {
          "hue": 120,
          "saturation": 0.2,
          "lightness": 0.4
        },
        "expected": {
          "r": 82,
          "g": 122,
          "b": 82
        }
      },
      "hslToRgbDifferentLightness": {
        "description": "Convert HSL with different lightness.",
        "input": {
          "hue": 240,
          "saturation": 1,
          "lightness": 0.8
        },
        "expected": {
          "r": 153,
          "g": 153,
          "b": 255
        }
      },
      "hslToRgbZeroLightness": {
        "description": "Convert HSL with zero lightness.",
        "input": {
          "hue": 180,
          "saturation": 1,
          "lightness": 0
        },
        "expected": {
          "r": 0,
          "g": 0,
          "b": 0
        }
      }
    }
  },
  {
    "define": "_functions.Math.Hue",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the hue of a color in degrees, in the range [0..360].",
    "parameters": {
      "color": {
        "type": "_types.Dictionary",
        "description": "The color to get the hue from, in HSL format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function getHue(color) {\n  return color.h;\n}\n\nreturn getHue($$args.color);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hue of the color in degrees."
    },
    "tests": {
      "hueSimple": {
        "description": "Get the hue of a simple color.",
        "input": {
          "color": {
            "h": 120,
            "s": 1,
            "l": 0.5
          }
        },
        "expected": 120
      },
      "hueRed": {
        "description": "Get the hue of the color red.",
        "input": {
          "color": {
            "h": 0,
            "s": 1,
            "l": 0.5
          }
        },
        "expected": 0
      },
      "hueBlue": {
        "description": "Get the hue of the color blue.",
        "input": {
          "color": {
            "h": 240,
            "s": 1,
            "l": 0.5
          }
        },
        "expected": 240
      },
      "hueYellow": {
        "description": "Get the hue of the color yellow.",
        "input": {
          "color": {
            "h": 60,
            "s": 1,
            "l": 0.5
          }
        },
        "expected": 60
      }
    }
  },
  {
    "define": "_functions.Math.Hypot",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the hypotenuse of a right-angled triangle given the lengths of the other two sides.",
    "parameters": {
      "side1": {
        "type": "_types.Number",
        "description": "The length of the first side."
      },
      "side2": {
        "type": "_types.Number",
        "description": "The length of the second side."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.hypot($$args.side1, $$args.side2);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The length of the hypotenuse."
    },
    "tests": {
      "hypotThreeFour": {
        "description": "Calculate the hypotenuse of a right-angled triangle with sides 3 and 4.",
        "input": {
          "side1": 3,
          "side2": 4
        },
        "expected": 5
      },
      "hypotFiveTwelve": {
        "description": "Calculate the hypotenuse of a right-angled triangle with sides 5 and 12.",
        "input": {
          "side1": 5,
          "side2": 12
        },
        "expected": 13
      },
      "hypotZero": {
        "description": "Calculate the hypotenuse when one side is 0.",
        "input": {
          "side1": 0,
          "side2": 7
        },
        "expected": 7
      },
      "hypotBothZero": {
        "description": "Calculate the hypotenuse when both sides are 0.",
        "input": {
          "side1": 0,
          "side2": 0
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Logical.IF",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Evaluates a condition and returns one value if true, and another value otherwise.",
    "parameters": {
      "condition": {
        "type": "_types.Boolean",
        "description": "The condition to evaluate."
      },
      "then": {
        "type": "_types.Any",
        "description": "The value to return if the condition is true."
      },
      "else": {
        "type": "_types.Any",
        "description": "The value to return if the condition is false."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.condition) {\n  return $$args.then;\n} else {\n  return $$args.else;\n}\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The result of evaluating the condition and returning one of the specified values."
    },
    "tests": {
      "ifTrue": {
        "description": "Evaluate a true condition.",
        "input": {
          "condition": true,
          "then": "then",
          "else": "else"
        },
        "expected": "then"
      },
      "ifFalse": {
        "description": "Evaluate a false condition.",
        "input": {
          "condition": false,
          "then": "then",
          "else": "else"
        },
        "expected": "else"
      },
      "ifConditional": {
        "description": "Evaluate a conditional expression with true and false cases.",
        "input": {
          "condition": true,
          "then": "true result",
          "else": "false result"
        },
        "expected": "true result"
      }
    }
  },
  {
    "define": "_functions.Logical.ISEmail",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Determines whether the given text is a valid email address or not.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to check for being an email address."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const re = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\nreturn Boolean(re.test($$args.text));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the text is a valid email address or not."
    },
    "tests": {
      "isEmailSimple": {
        "description": "Check for a simple email.",
        "input": {
          "text": "john.doe@example.com"
        },
        "expected": true
      },
      "isEmailInvalid1": {
        "description": "Check for an invalid email with no @ symbol.",
        "input": {
          "text": "johndoeexamplecom"
        },
        "expected": false
      },
      "isEmailInvalid2": {
        "description": "Check for an invalid email without a domain.",
        "input": {
          "text": "john.doe@"
        },
        "expected": false
      },
      "isEmailInvalid3": {
        "description": "Check for an invalid email with multiple @ symbols.",
        "input": {
          "text": "john.doe@@example.com"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.List.ISEmpty",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a list is empty.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to check for emptiness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input.length === 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the list is empty or not."
    },
    "tests": {
      "isEmptyList": {
        "description": "Check an empty list.",
        "input": {
          "input": []
        },
        "expected": true
      },
      "nonEmptyList": {
        "description": "Check a non-empty list.",
        "input": {
          "input": ["a", "b"]
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Logical.ISEqual",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if two values are equal.",
    "parameters": {
      "value1": {
        "type": "_types.Any",
        "description": "The first value to compare."
      },
      "value2": {
        "type": "_types.Any",
        "description": "The second value to compare."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value1 === $$args.value2;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the two values are equal or not."
    },
    "tests": {
      "isEqualTrue": {
        "description": "Compare two identical values.",
        "input": {
          "value1": true,
          "value2": true
        },
        "expected": true
      },
      "isEqualFalse": {
        "description": "Compare two different values.",
        "input": {
          "value1": true,
          "value2": false
        },
        "expected": false
      },
      "isEqualMixedType": {
        "description": "Compare a number and a string.",
        "input": {
          "value1": 5,
          "value2": "5"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Any.IsNull",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the input value is null or undefined, false otherwise.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The value to check for nullness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input === null || $$args.input === undefined;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the input is null or undefined."
    },
    "tests": {
      "isNullTrue": {
        "description": "Test that ISNULL returns true for null values.",
        "input": {
          "input": null
        },
        "expected": true
      },
      "isNullFalse": {
        "description": "Test that ISNULL returns false for non-null values.",
        "input": {
          "input": "hello"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Boolean.IsNullOrEmpty",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the given input is null or an empty string.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The input to check for null or empty string."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input === null || $$args.input === '';\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the input is null or an empty string."
    },
    "tests": {
      "isNullOrEmptyNull": {
        "description": "Check if a null value is considered null or empty.",
        "input": {
          "input": null
        },
        "expected": true
      },
      "isNullOrEmptyEmptyString": {
        "description": "Check if an empty string is considered null or empty.",
        "input": {
          "input": ""
        },
        "expected": true
      },
      "isNullOrEmptyNotNull": {
        "description": "Check if a non-null value is not considered null or empty.",
        "input": {
          "input": "Hello"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.ISSame",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given input is equal to another input.",
    "parameters": {
      "first": {
        "type": "_types.Any",
        "description": "The value to compare."
      },
      "second": {
        "type": "_types.Any",
        "description": "The value to compare with."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.first === $$args.second;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the two inputs are equal or not."
    },
    "tests": {
      "issameTrue": {
        "description": "Compare two identical values.",
        "input": {
          "first": "Hello",
          "second": "Hello"
        },
        "expected": true
      },
      "issameFalse": {
        "description": "Compare two different values.",
        "input": {
          "first": "Hello",
          "second": "World"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Any.ISUndefined",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Determines if a value is undefined.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The value to check for undefininess."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input === undefined;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the input value is undefined or not."
    },
    "tests": {
      "isUndefinedTrue": {
        "description": "Check if a defined variable is not undefined.",
        "input": {
          "input": "hello"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.String.IndexOf",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the index of the first occurrence of a specified value in a given string.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The input string to search."
      },
      "target": {
        "type": "_types.String",
        "description": "The target value to find."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.indexOf($$args.target);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The index of the first occurrence of the target value."
    },
    "tests": {
      "indexOfFirstMatch": {
        "description": "Find the first occurrence of a string.",
        "input": {
          "text": "hello world",
          "target": "world"
        },
        "expected": 6
      },
      "indexOfNoMatch": {
        "description": "Attempt to find when no match is found.",
        "input": {
          "text": "hello world",
          "target": "foo"
        },
        "expected": -1
      },
      "indexOfStart": {
        "description": "Find the first occurrence of a string that matches the start.",
        "input": {
          "text": "hello world",
          "target": "hello"
        },
        "expected": 0
      },
      "indexOfMiddle": {
        "description": "Find the first occurrence of a string that matches the middle.",
        "input": {
          "text": "hello world",
          "target": "lo wo"
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.List.InsertItemAt",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Inserts an item at a given index in the list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to insert into."
      },
      "index": {
        "type": "_types.Number",
        "description": "The index where the new item should be inserted."
      },
      "item": {
        "type": "_types.Any",
        "description": "The item to be inserted."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = $$args.input.slice(0, $$args.index);\nresult.push($$args.item);\nreturn result.concat($$args.input.slice($$args.index));\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The modified list with the new item inserted."
    },
    "tests": {
      "insertItemAtBegin": {
        "description": "Insert an item at the beginning of the list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 0,
          "item": "d"
        },
        "expected": ["d", "a", "b", "c"]
      },
      "insertItemAtMiddle": {
        "description": "Insert an item in the middle of the list.",
        "input": {
          "input": ["a", "b", "c", "d", "e"],
          "index": 2,
          "item": "f"
        },
        "expected": ["a", "b", "f", "c", "d", "e"]
      },
      "insertItemAtEnd": {
        "description": "Insert an item at the end of the list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 3,
          "item": "d"
        },
        "expected": ["a", "b", "c", "d"]
      }
    }
  },
  {
    "define": "_functions.Math.Integer",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the integer value of a number.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The input value to be converted to an integer."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.floor($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Integer",
      "description": "The integer value of the input."
    },
    "tests": {
      "intWholeNumber": {
        "description": "Test converting a whole number.",
        "input": {
          "value": 5
        },
        "expected": 5
      },
      "intDecimal": {
        "description": "Test converting a decimal number to an integer.",
        "input": {
          "value": 4.2
        },
        "expected": 4
      }
    }
  },
  {
    "define": "_functions.List.Intersection",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list that contains only the elements that are present in both input lists.",
    "parameters": {
      "set1": {
        "type": "_types.List",
        "description": "The first list to find common elements."
      },
      "set2": {
        "type": "_types.List",
        "description": "The second list to find common elements."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.set1.filter(function(x) {\n  return $$args.set2.includes(x);\n});\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A new list containing only the common elements."
    },
    "tests": {
      "intersectionSameElements": {
        "description": "Find the intersection of two lists with some common elements.",
        "input": {
          "set1": ["a", "b", "c"],
          "set2": ["b", "c", "d"]
        },
        "expected": ["b", "c"]
      },
      "intersectionNoCommonElements": {
        "description": "Find the intersection of two lists without any common elements.",
        "input": {
          "set1": ["a", "b", "c"],
          "set2": ["x", "y", "z"]
        },
        "expected": []
      },
      "intersectionOneCommonElement": {
        "description": "Find the intersection of two lists with only one common element.",
        "input": {
          "set1": ["a", "b", "c"],
          "set2": ["c", "d", "e"]
        },
        "expected": ["c"]
      }
    }
  },
  {
    "define": "_functions.Date.IsBefore",
    "blueprint": "_blueprints.Flowgraph",
    "description": "Checks if the provided date is before a specified date.",
    "parameters": {
      "value": {
        "type": "_types.Date",
        "description": "The value to check."
      },
      "comparisonDate": {
        "type": "_types.Date",
        "description": "The date to compare against."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value < $$args.comparisonDate;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the provided date is before the comparison date, false otherwise."
    },
    "tests": {
      "DateIsAfter": {
        "description": "Test with a date that is after the comparison date.",
        "input": {
          "value": "new Date('2022-01-01')",
          "comparisonDate": "new Date('2021-01-01')"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Date.IsDate",
    "blueprint": "_blueprints.Flowgraph",
    "description": "Checks if the provided value is a date.",
    "parameters": {
      "value": {
        "type": "_types.Date",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value instanceof Date && !isNaN($$args.value.valueOf());\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is a date, false otherwise."
    },
    "tests": {
      "InvalidDate": {
        "description": "Test with an invalid date.",
        "input": {
          "value": "Hello, World!"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Logical.IsDatetime",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a given input is a valid datetime.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The input to check for being a datetime."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if (typeof $$args.input !== 'string') {\n  return false;\n}\nconst date = new Date($$args.input);\nreturn !isNaN(date.getTime()) && $$args.input === date.toISOString();\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the input is a valid datetime."
    },
    "tests": {
      "isDatetimeString": {
        "description": "Check if an ISO date string is a datetime.",
        "input": {
          "input": "2022-01-01T00:00:00.000Z"
        },
        "expected": true
      },
      "isDatetimeStringWithMilliseconds": {
        "description": "Check if an ISO date string with milliseconds is a datetime.",
        "input": {
          "input": "2022-01-01T00:00:00.123Z"
        },
        "expected": true
      },
      "isNotDatetimeString": {
        "description": "Check if a non-date string is not a datetime.",
        "input": {
          "input": "not a date"
        },
        "expected": false
      },
      "isNotDatetimeNumber": {
        "description": "Check if a number is not a datetime.",
        "input": {
          "input": 123456
        },
        "expected": false
      },
      "isNotDatetimeNull": {
        "description": "Check if null is not a datetime.",
        "input": {
          "input": null
        },
        "expected": false
      },
      "isNotDatetimeInvalidString": {
        "description": "Check if an invalid ISO date string is not a datetime.",
        "input": {
          "input": "2022-13-01T00:00:00.000Z"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.IsEven",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns whether the given number is even.",
    "parameters": {
      "num": {
        "type": "_types.Number",
        "description": "The number to check if it's even."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return ($$args.num) % 2 === 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the number is even."
    },
    "tests": {
      "isEvenZero": {
        "description": "Check if 0 is even.",
        "input": {
          "num": 0
        },
        "expected": true
      },
      "isEvenOne": {
        "description": "Check if 1 is even.",
        "input": {
          "num": 1
        },
        "expected": false
      },
      "isEvenTwo": {
        "description": "Check if 2 is even.",
        "input": {
          "num": 2
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Boolean.IsFunction",
    "blueprint": "_blueprints.Function",
    "description": "Checks if the provided value is a function.",
    "parameters": {
      "value": {
        "type": "_types.Any",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return typeof $$args.value === 'function';\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is a function, false otherwise."
    },
    "tests": null
  },
  {
    "define": "_functions.Math.IsInArray",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the given value is present in the array.",
    "parameters": {
      "array": {
        "type": "_types.List",
        "description": "The array to search."
      },
      "value": {
        "type": "_types.Any",
        "description": "The value to check for presence in the array."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.array.includes($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is present, false otherwise."
    },
    "tests": {
      "isInArrayTrue": {
        "description": "Check if a value is present in an array.",
        "input": {
          "array": ["a", "b", "c"],
          "value": "b"
        },
        "expected": true
      },
      "isInArrayFalse": {
        "description": "Check if a value is not present in an array.",
        "input": {
          "array": ["a", "b", "c"],
          "value": "d"
        },
        "expected": false
      },
      "isInArrayNumber": {
        "description": "Check if a number is present in an array of numbers.",
        "input": {
          "array": [1, 2, 3],
          "value": 2
        },
        "expected": true
      },
      "isInArrayMixedTypes": {
        "description": "Check if a value is present in an array with mixed types.",
        "input": {
          "array": [1, "2", true, null],
          "value": "2"
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.List.IsInArrayByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given key exists in any of the dictionaries in the input list and has the expected value.",
    "parameters": {
      "arrs": {
        "type": "_types.List[Dictionary]",
        "description": "The list of dictionaries to search."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to look for in each dictionary."
      },
      "value": {
        "type": "_types.Any",
        "description": "The expected value associated with the given key."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.arrs.some((dict) => dict[$$args.key] === $$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the given key exists in any of the dictionaries and has the expected value."
    },
    "tests": {
      "isInArrayByKeySimple": {
        "description": "Search for a simple key-value pair.",
        "input": {
          "arrs": [
            {
              "a": "1"
            },
            {
              "b": "2"
            }
          ],
          "key": "a",
          "value": "1"
        },
        "expected": true
      },
      "isInArrayByKeyNotFound": {
        "description": "Search for a key that does not exist in any of the dictionaries.",
        "input": {
          "arrs": [
            {
              "b": "2"
            }
          ],
          "key": "a",
          "value": "3"
        },
        "expected": false
      },
      "isInArrayByKeyDifferentValue": {
        "description": "Search for a key with a different value.",
        "input": {
          "arrs": [
            {
              "a": "1"
            },
            {
              "b": "2"
            }
          ],
          "key": "a",
          "value": "2"
        },
        "expected": false
      },
      "isInArrayByKeyNumber": {
        "description": "Search for a key with a number value.",
        "input": {
          "arrs": [
            {
              "a": 1
            },
            {
              "b": 2
            }
          ],
          "key": "a",
          "value": 1
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.IsInteger",
    "blueprint": "_blueprints.Flowgraph",
    "description": "Checks if the input value is an integer.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Number.isInteger($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is an integer, false otherwise."
    },
    "tests": {
      "IntegerNumber": {
        "description": "The input value is an integer.",
        "input": {
          "value": 2
        },
        "expected": true
      },
      "NonIntegerNumber": {
        "description": "The input value is not an integer.",
        "input": {
          "value": 2.5
        },
        "expected": false
      },
      "NegativeIntegerNumber": {
        "description": "The input value is a negative integer.",
        "input": {
          "value": -2
        },
        "expected": true
      },
      "NegativeNonIntegerNumber": {
        "description": "The input value is a negative non-integer.",
        "input": {
          "value": -2.5
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.List.IsList",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the provided value is a list.",
    "parameters": {
      "value": {
        "type": "_types.List",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Array.isArray($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is a list, false otherwise."
    },
    "tests": {
      "ValidList": {
        "description": "Test with a valid list.",
        "input": {
          "value": [1, 2, 3]
        },
        "expected": true
      },
      "InvalidList": {
        "description": "Test with an invalid list.",
        "input": {
          "value": "Not a list"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Number.IsNan",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given number is Not a Number (NaN), and false otherwise.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to check for NaN-ness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return isNaN($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the input value is NaN or not."
    },
    "tests": {
      "isNanTrue": {
        "description": "Check a NaN value.",
        "input": {
          "value": "NaN"
        },
        "expected": true
      },
      "isNanFalse": {
        "description": "Check a non-NaN value.",
        "input": {
          "value": 42
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Number.IsNegative",
    "blueprint": "_blueprints.Flowgraph",
    "description": "Checks if the input value is negative.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value < 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is negative, false otherwise."
    },
    "tests": {
      "NegativeNumber": {
        "description": "The input value is a negative number.",
        "input": {
          "value": -1
        },
        "expected": true
      },
      "PositiveNumber": {
        "description": "The input value is a positive number.",
        "input": {
          "value": 1
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.IsNumber",
    "blueprint": "_blueprints.Flowgraph",
    "description": "Checks if the provided value is a number.",
    "parameters": {
      "value": {
        "type": "_types.Any",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return typeof $$args.value === 'number';\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is a number, false otherwise."
    },
    "tests": {
      "ValidNumber": {
        "description": "Test with a valid number.",
        "input": {
          "value": 42
        },
        "expected": true
      },
      "InvalidNumber": {
        "description": "Test with an invalid number.",
        "input": {
          "value": "Hello, World!"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.IsOdd",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given number is odd, false otherwise.",
    "parameters": {
      "input": {
        "type": "_types.Number",
        "description": "The number to check for oddness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input % 2 !== 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the given number is odd or not."
    },
    "tests": {
      "isOddZero": {
        "description": "Check if 0 is an odd number.",
        "input": {
          "input": 0
        },
        "expected": false
      },
      "isOddOne": {
        "description": "Check if 1 is an odd number.",
        "input": {
          "input": 1
        },
        "expected": true
      },
      "isOddTwo": {
        "description": "Check if 2 is an odd number.",
        "input": {
          "input": 2
        },
        "expected": false
      },
      "isOddNegativeOne": {
        "description": "Check if -1 is an odd number.",
        "input": {
          "input": -1
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.String.IsString",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the provided value is a string.",
    "parameters": {
      "value": {
        "type": "_types.Any",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return typeof $$args.value === 'string';\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value is a string, false otherwise."
    },
    "tests": {
      "ValidString": {
        "description": "Test with a valid string.",
        "input": {
          "value": "Hello, World!"
        },
        "expected": true
      },
      "InvalidString": {
        "description": "Test with an invalid string.",
        "input": {
          "value": 42
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.List.Join"
  },
  {
    "define": "_functions.List.LastItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the last item in a list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to get the last item from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input.length > 0 ? $$args.input[$$args.input.length - 1] : null;\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The last item in the list."
    },
    "tests": {
      "lastItemInList": {
        "description": "Get the last item in a list.",
        "input": {
          "input": ["a", "b", "c"]
        },
        "expected": "c"
      },
      "lastItemInEmptyList": {
        "description": "Attempt to get the last item from an empty list.",
        "input": {
          "input": []
        },
        "expected": null
      },
      "lastItemInSingleElementList": {
        "description": "Get the last item in a list with only one element.",
        "input": {
          "input": ["x"]
        },
        "expected": "x"
      }
    }
  },
  {
    "define": "_functions.Math.LeastCommonMultiple",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the least common multiple (LCM) of two given numbers.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function gcd(a, b) {\n  if (b === 0) return a;\n  return gcd(b, a % b);\n}\nfunction lcm(a, b) {\n  if (a === 0 || b === 0) return 0;\n  return Math.abs(a * b) / gcd(a, b);\n}\nreturn lcm($$args.a, $$args.b);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The least common multiple of the two numbers."
    },
    "tests": {
      "lcmSimple": {
        "description": "Calculate the LCM of simple numbers.",
        "input": {
          "a": 4,
          "b": 6
        },
        "expected": 12
      },
      "lcmNegative": {
        "description": "Calculate the LCM of negative numbers.",
        "input": {
          "a": -8,
          "b": -12
        },
        "expected": -24
      },
      "lcmZero": {
        "description": "Calculate the LCM when one number is zero.",
        "input": {
          "a": 0,
          "b": 5
        },
        "expected": 0
      },
      "lcmBothZero": {
        "description": "Calculate the LCM when both numbers are zero.",
        "input": {
          "a": 0,
          "b": 0
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.String.LeftPad",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Pads a string to the left with a specified filler character.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The original string to be padded."
      },
      "length": {
        "type": "_types.Number",
        "description": "The desired length of the padded string."
      },
      "filler": {
        "type": "_types.String",
        "description": "The character used to pad the string."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = $$args.text;\nif (result.length < $$args.length) {\n  for (let i = 0; i < ($$args.length - result.length); i++) {\n    result = $$args.filler + result;\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The padded string."
    },
    "tests": {
      "leftPadSimple": {
        "description": "Pad a simple string.",
        "input": {
          "text": "hello",
          "length": 10,
          "filler": " "
        },
        "expected": "   hello"
      },
      "leftPadLongerThanText": {
        "description": "Pad the string when it's shorter than the desired length.",
        "input": {
          "text": "hi",
          "length": 20,
          "filler": "-"
        },
        "expected": "---------hi"
      },
      "leftPadEqualLength": {
        "description": "The original string is already at the desired length.",
        "input": {
          "text": "hello",
          "length": 5,
          "filler": "*"
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.String.LeftStrip",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes leading whitespace characters from the input string.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The input string to strip."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.trimLeft().toString();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The input string with leading whitespace removed."
    },
    "tests": {
      "leftStripSimple": {
        "description": "Strip leading whitespace from a simple string.",
        "input": {
          "text": "   hello"
        },
        "expected": "hello"
      },
      "leftStripMultipleSpaces": {
        "description": "Strip multiple spaces from the beginning of a string.",
        "input": {
          "text": "     world"
        },
        "expected": "world"
      },
      "leftStripNoWhitespace": {
        "description": "Strip when there is no leading whitespace.",
        "input": {
          "text": "hello"
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.Math.LessThan",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Check if a number is less than another number.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number to be compared."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number to be compared."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a < $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Returns true if a is less than b, and false otherwise."
    },
    "tests": {
      "lessThanTest": {
        "description": "Check if a number is less than another number.",
        "input": {
          "a": 3,
          "b": 5
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.LessThanOrEqual",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Check if a number is less than or equal to another number.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number to be compared."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number to be compared."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a <= $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Returns true if a is less than or equal to b, and false otherwise."
    },
    "tests": {
      "lessThanOrEqualTest": {
        "description": "Check if a number is less than or equal to another number.",
        "input": {
          "a": 3,
          "b": 5
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.Lighten",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Lightens a color by increasing its lightness.",
    "parameters": {
      "color": {
        "type": "_types.Dictionary",
        "description": "The color to lighten, in HSL format."
      },
      "amount": {
        "type": "_types.Number",
        "description": "The amount to lighten the color by (0-1.0)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function lighten(color, amount) {\n  const newLightness = Math.min(color.l + amount, 1.0);\n  return { h: color.h, s: color.s, l: newLightness };\n}\n\nreturn lighten($$args.color, $$args.amount);\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The lightened color in HSL format."
    },
    "tests": {
      "lightenSimple": {
        "description": "Lighten a simple color.",
        "input": {
          "color": {
            "h": 120,
            "s": 1,
            "l": 0.5
          },
          "amount": 0.2
        },
        "expected": {
          "h": 120,
          "s": 1,
          "l": 0.7
        }
      },
      "lightenToMax": {
        "description": "Lighten a color to the maximum lightness.",
        "input": {
          "color": {
            "h": 240,
            "s": 1,
            "l": 0.9
          },
          "amount": 0.2
        },
        "expected": {
          "h": 240,
          "s": 1,
          "l": 1
        }
      }
    }
  },
  {
    "define": "_functions.Math.Lightness",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the lightness of a given color.",
    "parameters": {
      "color": {
        "type": "_types.String",
        "description": "The color to calculate the lightness of, in the format \"RRGGBB\" where RR is red, GG is green, and BB is blue."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const rgb = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/g.exec($$args.color);\nif (rgb) {\n  const r = parseInt(rgb[1], 16) / 255,\n        g = parseInt(rgb[2], 16) / 255,\n        b = parseInt(rgb[3], 16) / 255;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const lightness = (max + min) / 2;\n  return lightness;\n} else {\n  throw new Error('Invalid color');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The lightness of the color."
    },
    "tests": {
      "lightnessSimple": {
        "description": "Calculate the lightness of a simple RGB color.",
        "input": {
          "color": "#FFFFFF"
        },
        "expected": 1
      },
      "lightnessComplex": {
        "description": "Calculate the lightness of a complex RGB color.",
        "input": {
          "color": "#FF0000"
        },
        "expected": 0.5
      },
      "lightnessMid": {
        "description": "Calculate the lightness of a mid-tone RGB color.",
        "input": {
          "color": "#808080"
        },
        "expected": 0.5019607843137255
      }
    }
  },
  {
    "define": "_functions.List.Contains",
    "blueprint": "_blueprints.Function",
    "description": "Checks if a list contains a specific value",
    "parameters": {
      "list": {
        "type": "_types.List",
        "items": {
          "type": "_types.Any"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.list.includes($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean"
    },
    "tests": {
      "test1": {
        "description": "Should return true if the list contains the value",
        "input": {
          "list": [1, 2, 3, 4, 5],
          "value": 3
        },
        "expected": true
      },
      "test2": {
        "description": "Should return false if the list does not contain the value",
        "input": {
          "list": [1, 2, 3, 4, 5],
          "value": 6
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.List.Length",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns length of given list",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The list to get the length of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.list.length\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The length of the list."
    },
    "tests": {
      "greaterThanZero": {
        "description": "Should return greater than zero",
        "input": {
          "list": [1, 2]
        },
        "expected": 2
      },
      "empty": {
        "description": "Should return 0 for empty list",
        "input": {
          "list": []
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Date.LocalTimezone",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the local timezone information.",
    "parameters": {
      "input": {
        "type": "_types.Any",
        "description": "The input to get local timezone from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return new Date().getTimezoneOffset();\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The local timezone offset in minutes."
    },
    "tests": {
      "localTimezoneSimple": {
        "description": "Get the local timezone.",
        "input": {},
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.String.Log",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Logs a string",
    "parameters": {
      "messages": {
        "type": "_types.List",
        "items": {
          "type": "_types.String"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "console.log($$args.messages.join('\\n'))\n"
      }
    },
    "tests": {
      "log1": {
        "description": "Logs a string",
        "input": {
          "messages": ["Hello Log call 1"]
        },
        "expected": null
      },
      "log2": {
        "description": "Logs multiple strings",
        "input": {
          "messages": ["Hello Log call 2", "Hello Log call 3"]
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.Math.Log10",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the base-10 logarithm of a given number.",
    "parameters": {
      "input": {
        "type": "_types.Number",
        "description": "The number to calculate the log of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function log10(input) {\n  if (input <= 0) {\n    return null; // Or handle it as needed for invalid inputs\n  }\n  return Math.log10(input);\n}\nreturn log10($$args.input);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The base-10 logarithm of the input number."
    },
    "tests": {
      "log10Positive": {
        "description": "Calculate the log of a positive number.",
        "input": {
          "input": 100
        },
        "expected": 2
      },
      "log10One": {
        "description": "Calculate the log of 1.",
        "input": {
          "input": 1
        },
        "expected": 0
      },
      "log10Ten": {
        "description": "Calculate the log of 10.",
        "input": {
          "input": 10
        },
        "expected": 1
      },
      "log10Fraction": {
        "description": "Calculate the log of a fractional positive number.",
        "input": {
          "input": 0.1
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.Math.Log2",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the logarithm base 2 of a given number.",
    "parameters": {
      "input": {
        "type": "_types.Number",
        "description": "The number to calculate the log2 of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function log2(input) {\n  if (input <= 0) {\n    return null; // Or handle it as needed for invalid inputs\n  }\n  return Math.log2(input);\n}\nreturn log2($$args.input);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The logarithm base 2 of the input number."
    },
    "tests": {
      "log2One": {
        "description": "Calculate the log2 of 1.",
        "input": {
          "input": 1
        },
        "expected": 0
      },
      "log2Two": {
        "description": "Calculate the log2 of 2.",
        "input": {
          "input": 2
        },
        "expected": 1
      },
      "log2Four": {
        "description": "Calculate the log2 of 4.",
        "input": {
          "input": 4
        },
        "expected": 2
      },
      "log2Eight": {
        "description": "Calculate the log2 of 8.",
        "input": {
          "input": 8
        },
        "expected": 3
      },
      "log2Fraction": {
        "description": "Calculate the log2 of a fractional positive number.",
        "input": {
          "input": 0.5
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.Math.Logarithm",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the logarithm of a number with a specified base.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the logarithm of."
      },
      "base": {
        "type": "_types.Number",
        "description": "The base of the logarithm."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.log($$args.number) / Math.log($$args.base);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The logarithm of the number with the specified base."
    },
    "tests": {
      "logBase10": {
        "description": "Calculate the base-10 logarithm of a number.",
        "input": {
          "number": 100,
          "base": 10
        },
        "expected": 2
      },
      "logBase2": {
        "description": "Calculate the base-2 logarithm of a number.",
        "input": {
          "number": 8,
          "base": 2
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.List.Lookup",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Finds the first item in a list that matches the given value.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to search for the value."
      },
      "target": {
        "type": "_types.Any",
        "description": "The value to look up."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input.find((element) => element === $$args.target);\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The found item in the list, or undefined if not found."
    },
    "tests": {
      "lookupSimple": {
        "description": "Look up a simple value.",
        "input": {
          "input": ["apple", "banana", "orange"],
          "target": "banana"
        },
        "expected": "banana"
      },
      "lookupNotFound": {
        "description": "Attempt to look up when not found.",
        "input": {
          "input": ["apple", "banana", "orange"],
          "target": "grape"
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.String.LowerCase",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts a string to lowercase",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to convert to lowercase"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.toLowerCase();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The lowercase string"
    },
    "tests": {
      "fullLowercase": {
        "description": "Test with a lowercase string",
        "input": {
          "string": "hello"
        },
        "expected": "hello"
      },
      "fullUppercase": {
        "description": "Test with an uppercase string",
        "input": {
          "string": "WORLD"
        },
        "expected": "world"
      }
    }
  },
  {
    "define": "_functions.Math.Mix",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list that combines the elements of two lists in alternating order.",
    "parameters": {
      "list1": {
        "type": "_types.List",
        "description": "The first list to mix."
      },
      "list2": {
        "type": "_types.List",
        "description": "The second list to mix."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = [];\nfor (let i = 0; i < $$args.list1.length || i < $$args.list2.length; i++) {\n  if (i < $$args.list1.length) {\n    result.push($$args.list1[i]);\n  }\n  if (i < $$args.list2.length) {\n    result.push($$args.list2[i]);\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The mixed list."
    },
    "tests": {
      "mixTwoLists": {
        "description": "Mix two lists.",
        "input": {
          "list1": [1, 3],
          "list2": [2, 4]
        },
        "expected": [1, 2, 3, 4]
      }
    }
  },
  {
    "define": "_functions.String.MatchesRegex",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true or false if the text is matched by the given regular expression pattern.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to test."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The regular expression pattern to match against."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = new RegExp($$args.pattern);\nreturn regex.test($$args.text);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the text matches the regular expression pattern, otherwise false."
    },
    "tests": {
      "matchesRegexComplexPattern": {
        "description": "Test if the text matches a complex pattern.",
        "input": {
          "text": "abc123",
          "pattern": "^[a-z]+\\d+$"
        },
        "expected": true
      },
      "matchesRegexTrue": {
        "description": "Test if the text matches the given pattern.",
        "input": {
          "text": "hello world",
          "pattern": "^hello"
        },
        "expected": true
      },
      "matchesRegexFalse": {
        "description": "Test if the text does not match the given pattern.",
        "input": {
          "text": "hello world",
          "pattern": "world$"
        },
        "expected": true
      },
      "matchesRegexCaseInsensitive": {
        "description": "Test if the text matches the given pattern with case insensitivity.",
        "input": {
          "text": "Hello World",
          "pattern": "^hello"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.Max",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Finds the maximum value in a list of numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The list of numbers to find the maximum value in.",
        "items": {
          "type": "_types.Number"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.max(...$$args.numbers);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The maximum value in the list of numbers."
    },
    "tests": {
      "maxOfNumbers": {
        "description": "Find the maximum of a list of numbers.",
        "input": {
          "numbers": [4, 2, 8, 6]
        },
        "expected": 8
      },
      "maxWithNegativeNumbers": {
        "description": "Find the maximum of a list with negative numbers.",
        "input": {
          "numbers": [-1, -5, 0, 3]
        },
        "expected": 3
      },
      "maxSingleNumber": {
        "description": "Find the maximum of a list with a single number.",
        "input": {
          "numbers": [7]
        },
        "expected": 7
      }
    }
  },
  {
    "define": "_functions.List.Merge",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Merges multiple lists into one.",
    "parameters": {
      "lists": {
        "type": "_types.List",
        "description": "The list(s) to merge."
      },
      "from": {
        "type": "_types.Number",
        "description": "The index at which the merging starts. If omitted, all items are merged."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = [...$$args.lists];\nif ($$args.from !== undefined) {\n  result = result.slice($$args.from);\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The merged list(s)."
    },
    "tests": {
      "mergeSimple": {
        "description": "Merge two lists.",
        "input": {
          "lists": ["a", "b"],
          "from": 0
        },
        "expected": ["a", "b"]
      },
      "mergeThreeLists": {
        "description": "Merge three lists.",
        "input": {
          "lists": ["a", "b", "c", "d", "e", "f", "g"],
          "from": 2
        },
        "expected": ["c", "d", "e", "f", "g"]
      },
      "mergeOneList": {
        "description": "Merge a single list.",
        "input": {
          "lists": ["a", "b", "c"],
          "from": 0
        },
        "expected": ["a", "b", "c"]
      }
    }
  },
  {
    "define": "_functions.String.MimeType",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the MIME type of a given file extension.",
    "parameters": {
      "extension": {
        "type": "_types.String",
        "description": "The file extension to determine the MIME type for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const mimeTypes = {\n  \"txt\": \"text/plain\",\n  \"html\": \"text/html\",\n  \"css\": \"text/css\",\n  \"js\": \"application/javascript\",\n  \"json\": \"application/json\"\n};\nreturn mimeTypes[$$args.extension] || \"application/octet-stream\";\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The MIME type of the given file extension."
    },
    "tests": {
      "mimeTypeText": {
        "description": "Determine the MIME type for a text file.",
        "input": {
          "extension": "txt"
        },
        "expected": "text/plain"
      },
      "mimeTypeHtml": {
        "description": "Determine the MIME type for an HTML file.",
        "input": {
          "extension": "html"
        },
        "expected": "text/html"
      },
      "mimeTypeUnknown": {
        "description": "Determine the MIME type for an unknown file extension.",
        "input": {
          "extension": "xlr"
        },
        "expected": "application/octet-stream"
      }
    }
  },
  {
    "define": "_functions.Math.Min",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Finds the minimum value in a list of numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The list of numbers to find the minimum value in.",
        "items": {
          "type": "_types.Number"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.min(...$$args.numbers);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The minimum value in the list of numbers."
    },
    "tests": {
      "minOfNumbers": {
        "description": "Find the minimum of a list of numbers.",
        "input": {
          "numbers": [4, 2, 8, 6]
        },
        "expected": 2
      },
      "minWithNegativeNumbers": {
        "description": "Find the minimum of a list with negative numbers.",
        "input": {
          "numbers": [-1, -5, 0, 3]
        },
        "expected": -5
      },
      "minSingleNumber": {
        "description": "Find the minimum of a list with a single number.",
        "input": {
          "numbers": [7]
        },
        "expected": 7
      }
    }
  },
  {
    "define": "_functions.Math.Mod",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the remainder of the division of the input number by the given divisor.",
    "parameters": {
      "dividend": {
        "type": "_types.Number",
        "description": "The number to divide and find the remainder."
      },
      "divisor": {
        "type": "_types.Number",
        "description": "The number to divide by."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.dividend % $$args.divisor;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The remainder of the division."
    },
    "tests": {
      "modSimple": {
        "description": "Calculate the modulus of a simple integer.",
        "input": {
          "dividend": 10,
          "divisor": 3
        },
        "expected": 1
      },
      "modDecimal": {
        "description": "Calculate the modulus of a decimal number.",
        "input": {
          "dividend": -0.5,
          "divisor": 2
        },
        "expected": -0.5
      },
      "modNegative": {
        "description": "Calculate the modulus of negative numbers.",
        "input": {
          "dividend": -10,
          "divisor": 3
        },
        "expected": -1
      }
    }
  },
  {
    "define": "_functions.Math.Modulo",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the remainder of dividing the given number by a specified divisor.",
    "parameters": {
      "dividend": {
        "type": "_types.Number",
        "description": "The number to be divided."
      },
      "divisor": {
        "type": "_types.Number",
        "description": "The divisor."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.divisor === 0) {\n  throw new Error(\"Division by zero\");\n}\nreturn $$args.dividend % $$args.divisor;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The remainder of the division."
    },
    "tests": {
      "moduloOne": {
        "description": "Calculate the remainder when dividing by 1.",
        "input": {
          "dividend": 5,
          "divisor": 1
        },
        "expected": 0
      },
      "moduloTwo": {
        "description": "Calculate the remainder when dividing by 2.",
        "input": {
          "dividend": 5,
          "divisor": 2
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.Multinomial",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the multinomial coefficient of a given vector.",
    "parameters": {
      "vector": {
        "type": "_types.List<Number>",
        "description": "The input vector."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function factorial(n) {\n  if (n === 0 || n === 1) return 1;\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconst sum = (arr) => arr.reduce((a, b) => a + b, 0);\nconst numerator = factorial(sum($$args.vector));\nconst denominator = $$args.vector.reduce((acc, val) => acc * factorial(val), 1);\nreturn numerator / denominator;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The multinomial coefficient."
    },
    "tests": {
      "multinomialSimple": {
        "description": "Calculate the simple multinomial coefficient.",
        "input": {
          "vector": [2, 3]
        },
        "expected": 10
      },
      "multinomialComplex": {
        "description": "Calculate the multinomial coefficient for a more complex vector.",
        "input": {
          "vector": [1, 2, 3]
        },
        "expected": 60
      }
    }
  },
  {
    "define": "_functions.Math.Multiply",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Multiply two numbers.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a * $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The product of the two numbers."
    },
    "tests": {
      "multiplyTwo": {
        "description": "Multiply two numbers.",
        "input": {
          "a": 3,
          "b": 2
        },
        "expected": 6
      }
    }
  },
  {
    "define": "_functions.Logical.NOT",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the logical negation of a boolean value.",
    "parameters": {
      "input": {
        "type": "_types.Boolean",
        "description": "The boolean value to negate."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return !$$args.input;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "The negated boolean value."
    },
    "tests": {
      "notTrue": {
        "description": "Negate a true boolean value.",
        "input": {
          "input": true
        },
        "expected": false
      },
      "notFalse": {
        "description": "Negate a false boolean value.",
        "input": {
          "input": false
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Math.Base",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Provides the base of a numeric system.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The number to get the base from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The base of the numeric system."
    },
    "tests": {
      "baseValue": {
        "description": "Test the base with a simple value.",
        "input": {
          "value": 10
        },
        "expected": 10
      }
    }
  },
  {
    "define": "_functions.Math.Odd",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns true if the given number is odd, false otherwise.",
    "parameters": {
      "input": {
        "type": "_types.Number",
        "description": "The number to check for being odd."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input % 2 !== 0;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the given number is odd or not."
    },
    "tests": {
      "oddTrue": {
        "description": "Check if a positive odd number is returned as true.",
        "input": {
          "input": 3
        },
        "expected": true
      },
      "oddFalse": {
        "description": "Check if an even number is returned as false.",
        "input": {
          "input": 4
        },
        "expected": false
      },
      "oddZero": {
        "description": "Check if zero is not considered an odd number.",
        "input": {
          "input": 0
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Dictionary.OmitKeys",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new dictionary that contains all the key-value pairs from the input dictionary, except for those with keys specified in the omit list.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The input dictionary."
      },
      "omit": {
        "type": "_types.List",
        "description": "A list of keys to be omitted."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = {};\nfor (const key in $$args.input) {\n  if (!$$args.omit.includes(key)) {\n   result[key] = $$args.input[key];\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The new dictionary with the omitted keys removed."
    },
    "tests": {
      "omitKeysSimple": {
        "description": "Omit a few simple keys.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "omit": ["b", "c"]
        },
        "expected": {
          "a": 1
        }
      },
      "omitKeysMultiple": {
        "description": "Omit multiple keys from the dictionary.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4
          },
          "omit": ["b", "c", "d"]
        },
        "expected": {
          "a": 1
        }
      },
      "omitKeysNoOmission": {
        "description": "Omit no keys from the dictionary.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "omit": []
        },
        "expected": {
          "a": 1,
          "b": 2,
          "c": 3
        }
      }
    }
  },
  {
    "define": "_functions.List.Order",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list where the elements are reordered according to the given order.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The original list."
      },
      "order": {
        "type": "_types.List",
        "description": "The desired order of the elements."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = [];\nfor (let i = 0; i < $$args.order.length; i++) {\n  if ($$args.order[i] < $$args.input.length) {\n    result.push($$args.input[$$args.order[i]]);\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The reordered list."
    },
    "tests": {
      "orderSimple": {
        "description": "Reorder a simple list.",
        "input": {
          "input": ["a", "b", "c"],
          "order": [1, 0, 2]
        },
        "expected": ["b", "a", "c"]
      },
      "orderMultiple": {
        "description": "Reorder a longer list.",
        "input": {
          "input": ["x", "y", "z", "w", "v", "u"],
          "order": [3, 5, 1, 4, 2]
        },
        "expected": ["w", "u", "y", "v", "z"]
      },
      "orderAllItems": {
        "description": "Reorder a list where all items match the order.",
        "input": {
          "input": ["a", "b", "c"],
          "order": [0, 1, 2]
        },
        "expected": ["a", "b", "c"]
      },
      "orderPartial": {
        "description": "Reorder a list where the order array does not cover all indices.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "order": [2, 1]
        },
        "expected": ["c", "b"]
      }
    }
  },
  {
    "define": "_functions.String.PadLeft",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Pads a string on the left with a specified character until it reaches a certain length.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to pad."
      },
      "length": {
        "type": "_types.Number",
        "description": "The total length of the resulting string after padding."
      },
      "char": {
        "type": "_types.String",
        "description": "The character to pad with."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.padStart($$args.length, $$args.char);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The padded string."
    },
    "tests": {
      "padLeftWithSpaces": {
        "description": "Pad a string with spaces on the left.",
        "input": {
          "string": "hello",
          "length": 10,
          "char": " "
        },
        "expected": "     hello"
      },
      "padLeftWithZeros": {
        "description": "Pad a string with zeros on the left.",
        "input": {
          "string": "123",
          "length": 6,
          "char": "0"
        },
        "expected": "000123"
      },
      "padLeftEmptyString": {
        "description": "Pad an empty string with a specified character.",
        "input": {
          "string": "",
          "length": 5,
          "char": "*"
        },
        "expected": "*****"
      },
      "padLeftNoPaddingNeeded": {
        "description": "Pad a string where no padding is needed.",
        "input": {
          "string": "hello",
          "length": 3,
          "char": " "
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.String.PadRight",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Pads a string on the right with a specified character until it reaches a certain length.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to pad."
      },
      "length": {
        "type": "_types.Number",
        "description": "The total length of the resulting string after padding."
      },
      "char": {
        "type": "_types.String",
        "description": "The character to pad with."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.padEnd($$args.length, $$args.char);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The padded string."
    },
    "tests": {
      "padRightWithSpaces": {
        "description": "Pad a string with spaces on the right.",
        "input": {
          "string": "hello",
          "length": 10,
          "char": " "
        },
        "expected": "hello     "
      },
      "padRightWithZeros": {
        "description": "Pad a string with zeros on the right.",
        "input": {
          "string": "123",
          "length": 6,
          "char": "0"
        },
        "expected": "123000"
      },
      "padRightEmptyString": {
        "description": "Pad an empty string with a specified character.",
        "input": {
          "string": "",
          "length": 5,
          "char": "*"
        },
        "expected": "*****"
      },
      "padRightNoPaddingNeeded": {
        "description": "Pad a string where no padding is needed.",
        "input": {
          "string": "hello",
          "length": 3,
          "char": " "
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.Math.Pi",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the value of pi.",
    "parameters": {
      "none": {
        "type": "_types.Any",
        "description": "No parameters needed."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.PI;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The value of pi."
    },
    "tests": {
      "pi": {
        "description": "Get the value of pi.",
        "expected": 3.141592653589793
      }
    }
  },
  {
    "define": "_functions.List.PickItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Selects the item at the given index from a list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to select an item from."
      },
      "index": {
        "type": "_types.Number",
        "description": "The index of the item to select."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const idx = $$args.index < 0 ? $$args.input.length + $$args.index : $$args.index;\nreturn $$args.input[idx];\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The selected item."
    },
    "tests": {
      "pickItemSimple": {
        "description": "Select a simple item.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 1
        },
        "expected": "b"
      },
      "pickItemNegativeIndex": {
        "description": "Select an item by negative index from the end of the list.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "index": -2
        },
        "expected": "c"
      },
      "pickItemOutOfRange": {
        "description": "Attempt to select an item with an out-of-range index.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 5
        },
        "expected": null
      },
      "pickItemNegativeOutOfRange": {
        "description": "Attempt to select an item with a negative out-of-range index.",
        "input": {
          "input": ["a", "b", "c"],
          "index": -5
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.Dictionary.PickKeys",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new dictionary containing only the key-value pairs that have keys from the given list of keys.",
    "parameters": {
      "dict": {
        "type": "_types.Dictionary",
        "description": "The input dictionary to pick keys from."
      },
      "keys": {
        "type": "_types.List[String]",
        "description": "The list of keys to pick from the dictionary."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = {};\nfor (const key in $$args.dict) {\n  if ($$args.keys.includes(key)) {\n    result[key] = $$args.dict[key];\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The new dictionary containing the picked key-value pairs."
    },
    "tests": {
      "pickKeysSimple": {
        "description": "Pick all keys from a simple dictionary.",
        "input": {
          "dict": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "keys": ["a", "b"]
        },
        "expected": {
          "a": 1,
          "b": 2
        }
      },
      "pickKeysMultiple": {
        "description": "Pick multiple keys from a dictionary with duplicate keys.",
        "input": {
          "dict": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4,
            "e": 5
          },
          "keys": ["a", "c", "e"]
        },
        "expected": {
          "a": 1,
          "c": 3,
          "e": 5
        }
      },
      "pickKeysNoMatch": {
        "description": "Attempt to pick keys that are not in the dictionary.",
        "input": {
          "dict": {},
          "keys": ["a", "b", "c"]
        },
        "expected": {}
      }
    }
  },
  {
    "define": "_functions.Any.Pluck",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the values from a Dictionary (Object) based on the provided keys.",
    "parameters": {
      "dictionary": {
        "type": "_types.Dictionary",
        "description": "The object to retrieve values from."
      },
      "keys": {
        "type": "_types.List",
        "description": "A list of keys to retrieve values for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = {};\n$$args.keys.forEach(key => {\n  if (Object.prototype.hasOwnProperty.call($$args.dictionary, key)) {\n    result[key] = $$args.dictionary[key];\n  }\n});\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "A new dictionary containing the values from the provided keys."
    },
    "tests": {
      "pluckSimple": {
        "description": "Retrieve a simple value.",
        "input": {
          "dictionary": {
            "name": "John",
            "age": 30,
            "occupation": "Software Engineer"
          },
          "keys": ["name"]
        },
        "expected": {
          "name": "John"
        }
      },
      "pluckMultiple": {
        "description": "Retrieve multiple values.",
        "input": {
          "dictionary": {
            "name": "John",
            "age": 30,
            "occupation": "Software Engineer",
            "hobbies": ["reading", "coding"]
          },
          "keys": ["name", "age", "hobbies"]
        },
        "expected": {
          "name": "John",
          "age": 30,
          "hobbies": ["reading", "coding"]
        }
      },
      "pluckNonExistingKey": {
        "description": "Attempt to retrieve a value for a non-existent key.",
        "input": {
          "dictionary": {
            "name": "John",
            "age": 30,
            "occupation": "Software Engineer"
          },
          "keys": ["nonExistentKey"]
        },
        "expected": {}
      },
      "pluckEmptyKeysList": {
        "description": "Retrieve values from an empty list of keys.",
        "input": {
          "dictionary": {
            "name": "John",
            "age": 30,
            "occupation": "Software Engineer"
          },
          "keys": []
        },
        "expected": {}
      }
    }
  },
  {
    "define": "_functions.Math.Polynomial",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Evaluates a polynomial function given coefficients and an input value.",
    "parameters": {
      "coefficients": {
        "type": "_types.List(Number)",
        "description": "The coefficients of the polynomial, in order from highest to lowest degree."
      },
      "x": {
        "type": "_types.Number",
        "description": "The input value for which to evaluate the polynomial."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = 0;\nconst n = $$args.coefficients.length;\nfor (let i = 0; i < n; i++) {\n  result += $$args.coefficients[i] * Math.pow($$args.x, n - 1 - i);\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The evaluated polynomial at the given input value."
    },
    "tests": {
      "polySimple": {
        "description": "Evaluate a simple polynomial.",
        "input": {
          "coefficients": [1, -2, 3],
          "x": 1
        },
        "expected": 2
      },
      "polyComplex": {
        "description": "Evaluate a more complex polynomial.",
        "input": {
          "coefficients": [-3, 2, -1, 0.5],
          "x": 2
        },
        "expected": -17.5
      }
    }
  },
  {
    "define": "_functions.Math.Power",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Raise a number to a power.",
    "parameters": {
      "base": {
        "type": "_types.Number",
        "description": "The base number."
      },
      "exponent": {
        "type": "_types.Number",
        "description": "The exponent."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.pow($$args.base, $$args.exponent);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The base raised to the power of the exponent."
    },
    "tests": {
      "powerTwo": {
        "description": "Raise a number to a power.",
        "input": {
          "base": 2,
          "exponent": 3
        },
        "expected": 8
      }
    }
  },
  {
    "define": "_functions.Math.Product",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the product of all input numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List(Number)",
        "description": "The list of numbers to multiply together."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.numbers.reduce((acc, current) => acc * current, 1);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The product of the input numbers."
    },
    "tests": {
      "productSingle": {
        "description": "Calculate the product of a single number.",
        "input": {
          "numbers": [4]
        },
        "expected": 4
      },
      "productTwo": {
        "description": "Calculate the product of two numbers.",
        "input": {
          "numbers": [2, 3]
        },
        "expected": 6
      },
      "productThree": {
        "description": "Calculate the product of three numbers.",
        "input": {
          "numbers": [1, 2, 3]
        },
        "expected": 6
      },
      "productNegative": {
        "description": "Calculate the product of negative numbers.",
        "input": {
          "numbers": [-1, -2, -3]
        },
        "expected": -6
      }
    }
  },
  {
    "define": "_functions.List.QueryParametersArray",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns an array of query parameters.",
    "parameters": {
      "array": {
        "type": "_types.List",
        "description": "The input list to process."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.array;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "An array of query parameters."
    },
    "tests": {
      "queryParametersArraySimple": {
        "description": "Process a simple list.",
        "input": {
          "array": ["a", "b", "c"]
        },
        "expected": ["a", "b", "c"]
      }
    }
  },
  {
    "define": "_functions.Dictionary.QueryParametersObject",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new object containing the query parameters.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The input dictionary to extract query parameters from."
      },
      "param": {
        "type": "_types.String",
        "description": "The parameter name."
      },
      "value": {
        "type": "_types.Any",
        "description": "The parameter value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const queryParams = {};\nfor (const [key, val] of Object.entries($$args.input)) {\n  if ($$args.param === key) {\n    queryParams[$$args.param] = $$args.value;\n  }\n}\nreturn queryParams;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The query parameters object."
    },
    "tests": {
      "queryParametersObjectSimple": {
        "description": "Extract a single query parameter.",
        "input": {
          "input": {
            "a": "1",
            "b": "2"
          },
          "param": "a",
          "value": 1
        },
        "expected": {
          "a": 1
        }
      },
      "queryParametersObjectMultiple": {
        "description": "Extract multiple query parameters.",
        "input": {
          "input": {
            "a": "1",
            "b": "2",
            "c": "3"
          },
          "param": "b",
          "value": 2
        },
        "expected": {
          "b": 2
        }
      }
    }
  },
  {
    "define": "_functions.Math.RGB",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a string representing the RGB color from given red, green and blue components.",
    "parameters": {
      "r": {
        "type": "_types.Number",
        "description": "The value of the red component."
      },
      "g": {
        "type": "_types.Number",
        "description": "The value of the green component."
      },
      "b": {
        "type": "_types.Number",
        "description": "The value of the blue component."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return `rgb(${Math.min(255, Math.max(0, $$args.r))}, ${Math.min(255, Math.max(0, $$args.g))}, ${Math.min(255, Math.max(0, $$args.b))})`;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The string representation of the RGB color."
    },
    "tests": {
      "rgbFullRange": {
        "description": "Test full range of values.",
        "input": {
          "r": 255,
          "g": 128,
          "b": 64
        },
        "expected": "rgb(255, 128, 64)"
      },
      "rgbPartialRange": {
        "description": "Test partial range of values.",
        "input": {
          "r": 100,
          "g": 50,
          "b": 25
        },
        "expected": "rgb(100, 50, 25)"
      }
    }
  },
  {
    "define": "_functions.Math.Random",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Generates a random number between 0 (inclusive) and 1 (exclusive).",
    "parameters": {},
    "implementation": {
      "javascript": {
        "code": "return Math.random();\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "A random number between 0 (inclusive) and 1 (exclusive)."
    },
    "tests": null
  },
  {
    "define": "_functions.Math.RandomArray",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a random array of the given length.",
    "parameters": {
      "length": {
        "type": "_types.Number",
        "description": "The number of elements in the returned array."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const arr = [];\nfor (let i = 0; i < $$args.length; i++) {\n  arr.push(Math.random());\n}\nreturn arr;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A list of random numbers of the given length."
    },
    "tests": null
  },
  {
    "define": "_functions.Math.RandomIntegerBetween",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Generates a random integer between two specified values (inclusive).",
    "parameters": {
      "min": {
        "type": "_types.Number",
        "description": "The minimum value."
      },
      "max": {
        "type": "_types.Number",
        "description": "The maximum value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const min = Math.ceil($$args.min);\nconst max = Math.floor($$args.max);\nreturn Math.floor(Math.random() * (max - min + 1)) + min;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "A random integer between the specified min and max values (inclusive)."
    },
    "tests": null
  },
  {
    "define": "_functions.Math.RandomNumberBetween",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Generates a random number within a specified range.",
    "parameters": {
      "min": {
        "type": "_types.Number",
        "description": "The minimum value."
      },
      "max": {
        "type": "_types.Number",
        "description": "The maximum value."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.random() * ($$args.max - $$args.min) + $$args.min;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "A random number between the specified min and max values."
    },
    "tests": {
      "randomWithinRange": {
        "description": "Generate a random number within the range 1 to 10.",
        "input": {
          "min": 1,
          "max": 1
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.RED",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns an integer between 0 and 255 representing the color's red component.",
    "parameters": {
      "color": {
        "type": "_types.String",
        "description": "The color to extract the red component from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hexToRgb(hex) {\n  let shortHex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shortHex, function(m, r, g, b) {\n    return r + r + g + g + b + b;\n  });\n\n  let longHex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return longHex ? {\n    r: parseInt(longHex[1], 16),\n    g: parseInt(longHex[2], 16),\n    b: parseInt(longHex[3], 16)\n  } : null;\n}\n\nfunction hslToRgb(h, s, l) {\n  let r, g, b;\n\n  h /= 360;\n  s /= 100;\n  l /= 100;\n\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const hue2rgb = function(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n}\n\nfunction parseColor(color) {\n  let rgb;\n  \n  if (color.startsWith('#')) {\n    rgb = hexToRgb(color);\n  } else if (color.startsWith('rgb')) {\n    let values = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n    rgb = {\n      r: parseInt(values[1], 10),\n      g: parseInt(values[2], 10),\n      b: parseInt(values[3], 10)\n    };\n  } else if (color.startsWith('hsl')) {\n    let values = color.match(/hsl\\((\\d+),\\s*(\\d+)%?,\\s*(\\d+)%?\\)/);\n    rgb = hslToRgb(parseInt(values[1], 10), parseInt(values[2], 10), parseInt(values[3], 10));\n  } else {\n    let ctx = document.createElement('canvas').getContext('2d');\n    ctx.fillStyle = color;\n    rgb = hexToRgb(ctx.fillStyle);\n  }\n\n  return rgb;\n}\n\nlet rgb = parseColor($$args.color);\nif (rgb) {\n  return rgb.r;\n} else {\n  throw new Error('Invalid color');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The red component of the color."
    },
    "tests": {
      "redHexShort": {
        "description": "Extract the red component from a short hex color.",
        "input": {
          "color": "#ff0"
        },
        "expected": 255
      },
      "redRgb": {
        "description": "Extract the red component from an rgb color.",
        "input": {
          "color": "rgb(10, 20, 40)"
        },
        "expected": 10
      },
      "redHsl": {
        "description": "Extract the red component from an hsl color.",
        "input": {
          "color": "hsl(80, 20%, 40%)"
        },
        "expected": 109
      }
    }
  },
  {
    "define": "_functions.List.RemoveAll",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes all occurrences of a value from a list.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The list to remove the value from.",
        "items": {
          "type": "_types.Unknown"
        }
      },
      "value": {
        "type": "_types.Unknown",
        "description": "The value to remove from the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.list.filter(item => item !== $$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list with all occurrences of the value removed.",
      "items": {
        "type": "_types.Unknown"
      }
    },
    "tests": {
      "removeAllExistingValue": {
        "description": "Remove all occurrences of a value that exists in the list.",
        "input": {
          "list": [1, 2, 3, 2, 4, 2],
          "value": 2
        },
        "expected": [1, 3, 4]
      },
      "removeAllNonExistingValue": {
        "description": "Try to remove a value that does not exist in the list.",
        "input": {
          "list": [1, 2, 3, 4],
          "value": 5
        },
        "expected": [1, 2, 3, 4]
      },
      "removeAllFromEmptyList": {
        "description": "Try to remove a value from an empty list.",
        "input": {
          "list": [],
          "value": 1
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.List.RemoveItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes the item at the given index from the input list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The input list."
      },
      "index": {
        "type": "_types.Number",
        "description": "The index of the item to remove."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.index < 0 || $$args.index >= $$args.input.length) {\n  return $$args.input;\n}\nconst result = $$args.input.slice(0, $$args.index).concat($$args.input.slice($$args.index + 1));\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The input list with the item removed."
    },
    "tests": {
      "removeItemAtStart": {
        "description": "Remove the first item from the list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 0
        },
        "expected": ["b", "c"]
      },
      "removeItemInMiddle": {
        "description": "Remove an item in the middle of the list.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "index": 2
        },
        "expected": ["a", "b", "d"]
      },
      "removeItemAtEnd": {
        "description": "Remove the last item from the list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 2
        },
        "expected": ["a", "b"]
      },
      "removeItemNotPresent": {
        "description": "Attempt to remove an item that is not present in the list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 4
        },
        "expected": ["a", "b", "c"]
      },
      "removeItemNegativeIndex": {
        "description": "Attempt to remove an item with a negative index.",
        "input": {
          "input": ["a", "b", "c"],
          "index": -1
        },
        "expected": ["a", "b", "c"]
      }
    }
  },
  {
    "define": "_functions.Dictionary.RemoveItemByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes the item from a dictionary that has the given key.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The dictionary to remove an item from."
      },
      "key": {
        "type": "_types.String",
        "description": "The key of the item to remove."
      }
    },
    "implementation": {
      "javascript": {
        "code": "delete $$args.input[$$args.key];\nreturn $$args.input;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The updated dictionary with the removed item."
    },
    "tests": {
      "removeItemByKeySimple": {
        "description": "Remove an item from a simple dictionary.",
        "input": {
          "input": {
            "a": "1",
            "b": "2"
          },
          "key": "a"
        },
        "expected": {
          "b": "2"
        }
      },
      "removeItemByKeyMultipleKeys": {
        "description": "Remove an item from a dictionary with multiple keys.",
        "input": {
          "input": {
            "a": "1",
            "b": "2",
            "c": "3"
          },
          "key": "a"
        },
        "expected": {
          "b": "2",
          "c": "3"
        }
      },
      "removeItemByKeyNonExistent": {
        "description": "Attempt to remove an item with a non-existent key.",
        "input": {
          "input": {
            "a": "1",
            "b": "2"
          },
          "key": "c"
        },
        "expected": {
          "a": "1",
          "b": "2"
        }
      }
    }
  },
  {
    "define": "_functions.List.RemoveItemsAt",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes the items at the specified indices from a list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to remove items from."
      },
      "start": {
        "type": "_types.Number",
        "description": "The index of the first item to remove (0-based)."
      },
      "end": {
        "type": "_types.Number",
        "description": "The index where the range ends, not including the item at this index. Negative indices will be calculated from the end of the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const start = $$args.start < 0 ? $$args.input.length + $$args.start : $$args.start;\nconst end = $$args.end < 0 ? $$args.input.length + $$args.end : $$args.end;\nconst result = $$args.input.slice(0, start).concat($$args.input.slice(end));\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The original list with the items at the specified indices removed."
    },
    "tests": {
      "removeItemsAtStart": {
        "description": "Remove the item at the start of a list.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": 0,
          "end": 1
        },
        "expected": ["b", "c", "d"]
      },
      "removeItemsAtEnd": {
        "description": "Remove the item at the end of a list.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": -1,
          "end": -1
        },
        "expected": ["a", "b", "c", "d"]
      },
      "removeItemsMultiple": {
        "description": "Remove multiple items from a list.",
        "input": {
          "input": ["a", "b", "c", "d", "e", "f"],
          "start": 1,
          "end": 4
        },
        "expected": ["a", "e", "f"]
      },
      "removeItemsWithNegativeIndices": {
        "description": "Remove items using negative indices.",
        "input": {
          "input": ["a", "b", "c", "d", "e", "f"],
          "start": -4,
          "end": -2
        },
        "expected": ["a", "b", "e", "f"]
      }
    }
  },
  {
    "define": "_functions.List.Repeat",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Repeats the given list a specified number of times.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to repeat."
      },
      "count": {
        "type": "_types.Number",
        "description": "The number of times to repeat the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = [];\nif ($$args.count > 0) {\n  for (let i = 0; i < $$args.count; i++) {\n    result = result.concat($$args.input);\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The repeated list."
    },
    "tests": {
      "repeatSimple": {
        "description": "Repeat a simple list.",
        "input": {
          "input": ["a", "b"],
          "count": 3
        },
        "expected": ["a", "b", "a", "b", "a", "b"]
      },
      "repeatNegativeCount": {
        "description": "Repeat the list with a negative count.",
        "input": {
          "input": ["c", "d"],
          "count": -2
        },
        "expected": []
      },
      "repeatZeroCount": {
        "description": "Repeat the list with a zero count.",
        "input": {
          "input": ["e", "f"],
          "count": 0
        },
        "expected": []
      },
      "repeatOneCount": {
        "description": "Repeat the list with a count of one.",
        "input": {
          "input": ["g", "h"],
          "count": 1
        },
        "expected": ["g", "h"]
      }
    }
  },
  {
    "define": "_functions.String.Replace",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Replaces all occurrences of a substring in a string with another substring",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to replace substrings in"
      },
      "search": {
        "type": "_types.String",
        "description": "The substring to search for"
      },
      "replacement": {
        "type": "_types.String",
        "description": "The substring to replace the search substring with"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.replaceAll(new RegExp($$args.search, 'g'), $$args.replacement);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The string with the substrings replaced"
    },
    "tests": {
      "noOccurrences": {
        "description": "Test with no occurrences of the search string",
        "input": {
          "string": "hello",
          "search": "world",
          "replacement": "planet"
        },
        "expected": "hello"
      },
      "oneOccurrence": {
        "description": "Test with one occurrence of the search string",
        "input": {
          "string": "hello world",
          "search": "world",
          "replacement": "planet"
        },
        "expected": "hello planet"
      },
      "multipleOccurrences": {
        "description": "Test with multiple occurrences of the search string",
        "input": {
          "string": "hello world world",
          "search": "world",
          "replacement": "planet"
        },
        "expected": "hello planet planet"
      }
    }
  },
  {
    "define": "_functions.String.ReplaceAll",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new text where all occurrences of the given exact text are replaced with the given replacement text.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to search and replace."
      },
      "search": {
        "type": "_types.String",
        "description": "The exact text to search for."
      },
      "replacement": {
        "type": "_types.String",
        "description": "The replacement text."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.split($$args.search).join($$args.replacement);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The new text with all occurrences replaced."
    },
    "tests": {
      "replaceAllExactSimple": {
        "description": "Replace all occurrences of a simple text.",
        "input": {
          "text": "foo bar bar baz",
          "search": "bar",
          "replacement": "baz"
        },
        "expected": "foo baz baz baz"
      },
      "replaceAllExactMultipleMatches": {
        "description": "Replace all occurrences of the text.",
        "input": {
          "text": "foo foo baz",
          "search": "foo",
          "replacement": "bar"
        },
        "expected": "bar bar baz"
      },
      "replaceAllExactNoMatch": {
        "description": "Attempt to replace when no match is found.",
        "input": {
          "text": "foo bar baz",
          "search": "qux",
          "replacement": "quux"
        },
        "expected": "foo bar baz"
      },
      "replaceAllExactCaseSensitive": {
        "description": "Replace all occurrences of a text with case sensitivity.",
        "input": {
          "text": "Foo bar Baz bar",
          "search": "bar",
          "replacement": "qux"
        },
        "expected": "Foo qux Baz qux"
      }
    }
  },
  {
    "define": "_functions.String.ReplaceAllRegex",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new text where all matches for the given regular expression are replaced with the given replacement text.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to search and replace."
      },
      "pattern": {
        "type": "_types.String",
        "description": "The regular expression pattern to match."
      },
      "replacement": {
        "type": "_types.String",
        "description": "The replacement text."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = new RegExp($$args.pattern, 'g');\nreturn $$args.text.replace(regex, $$args.replacement);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The new text with all matches replaced."
    },
    "tests": {
      "replaceAllRegexSimple": {
        "description": "Replace all matches of a simple pattern.",
        "input": {
          "text": "one two one two",
          "pattern": "one",
          "replacement": "three"
        },
        "expected": "three two three two"
      },
      "replaceAllRegexMultipleMatches": {
        "description": "Replace all matches of the pattern.",
        "input": {
          "text": "hello hello hello",
          "pattern": "hello",
          "replacement": "hi"
        },
        "expected": "hi hi hi"
      },
      "replaceAllRegexNoMatch": {
        "description": "Attempt to replace when no match is found.",
        "input": {
          "text": "hello world",
          "pattern": "earth",
          "replacement": "planet"
        },
        "expected": "hello world"
      },
      "replaceAllRegexCaseInsensitive": {
        "description": "Replace all matches of a pattern with case insensitivity.",
        "input": {
          "text": "Hello World hello world",
          "pattern": "world",
          "replacement": "universe"
        },
        "expected": "Hello World hello universe"
      }
    }
  },
  {
    "define": "_functions.String.ReplaceOne",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new text where the first occurrence of the given exact text is replaced with the given replacement text.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to search and replace."
      },
      "search": {
        "type": "_types.String",
        "description": "The exact text to search for."
      },
      "replacement": {
        "type": "_types.String",
        "description": "The replacement text."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.replace($$args.search, $$args.replacement);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The new text with the first occurrence replaced."
    },
    "tests": {
      "replaceOneExactSimple": {
        "description": "Replace the first occurrence of a simple text.",
        "input": {
          "text": "foo bar baz",
          "search": "bar",
          "replacement": "baz"
        },
        "expected": "foo baz baz"
      },
      "replaceOneExactFirstMatch": {
        "description": "Replace only the first occurrence of the text.",
        "input": {
          "text": "foo foo baz",
          "search": "foo",
          "replacement": "bar"
        },
        "expected": "bar foo baz"
      },
      "replaceOneExactNoMatch": {
        "description": "Attempt to replace when no match is found.",
        "input": {
          "text": "foo bar baz",
          "search": "qux",
          "replacement": "quux"
        },
        "expected": "foo bar baz"
      },
      "replaceOneExactCaseSensitive": {
        "description": "Replace the first occurrence of a text with case sensitivity.",
        "input": {
          "text": "Foo bar Baz",
          "search": "bar",
          "replacement": "qux"
        },
        "expected": "Foo qux Baz"
      }
    }
  },
  {
    "define": "_functions.String.ReplaceOneRegex",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new text where the first match for the given regular expression is replaced with the given replacement text.",
    "parameters": {
      "text": {
        "type": "String",
        "description": "The text to search and replace."
      },
      "pattern": {
        "type": "String",
        "description": "The regular expression pattern to match."
      },
      "replacement": {
        "type": "String",
        "description": "The replacement text."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const regex = new RegExp($$args.pattern);\nreturn $$args.text.replace(regex, $$args.replacement);\n"
      }
    },
    "returns": {
      "type": "String",
      "description": "The new text with the first match replaced."
    },
    "tests": {
      "replaceOneRegexSimple": {
        "description": "Replace the first match of a simple pattern.",
        "input": {
          "text": "hello world",
          "pattern": "world",
          "replacement": "universe"
        },
        "expected": "hello universe"
      },
      "replaceOneRegexFirstMatch": {
        "description": "Replace only the first match of the pattern.",
        "input": {
          "text": "one two one two",
          "pattern": "one",
          "replacement": "three"
        },
        "expected": "three two one two"
      },
      "replaceOneRegexNoMatch": {
        "description": "Attempt to replace when no match is found.",
        "input": {
          "text": "hello world",
          "pattern": "earth",
          "replacement": "planet"
        },
        "expected": "hello world"
      },
      "replaceOneRegexCaseInsensitive": {
        "description": "Replace the first match of a pattern with case insensitivity.",
        "input": {
          "text": "Hello World",
          "pattern": "world",
          "replacement": "universe"
        },
        "expected": "Hello World"
      }
    }
  },
  {
    "define": "_functions.String.ReplaceURLParameters",
    "blueprint": "_blueprints.Function",
    "description": "Sets the given URL text's query parameters to the given parameter object.",
    "parameters": {
      "base_url": {
        "type": "_types.String",
        "description": "The base URL text"
      },
      "parameters": {
        "type": "_types.Map",
        "description": "A dictionary for parameters"
      }
    },
    "implementation": {
      "javascript": {
        "code": "const url = new URL($$args.base_url);\nObject.keys($$args.parameters).forEach((key) => {\n  url.searchParams.set(key, $$args.parameters[key]);\n});\nreturn url.href;"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The modified URL with the given parameters"
    },
    "tests": {
      "test1": {
        "description": "Test with a new set of parameters",
        "input": {
          "base_url": "http://www.example.com",
          "parameters": {
            "test1": "abc",
            "test2": 123
          }
        },
        "expected": "http://www.example.com/?test1=abc&test2=123"
      },
      "test2": {
        "description": "Test with an existing set of parameters",
        "input": {
          "base_url": "http://www.example.com/?abc=123&test=abc",
          "parameters": {
            "test1": "abc",
            "test2": 123
          }
        },
        "expected": "http://www.example.com/?abc=123&test=abc&test1=abc&test2=123"
      },
      "test3": {
        "description": "Test with an empty set of parameters",
        "input": {
          "base_url": "http://www.example.com/?abc=123&test=abc",
          "parameters": {}
        },
        "expected": "http://www.example.com/?abc=123&test=abc"
      }
    }
  },
  {
    "define": "_functions.Math.Reverse",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Reverses the order of elements in a list or characters in a string.",
    "parameters": {
      "input": {
        "type": "_types.Union",
        "description": "The list or string to reverse.",
        "options": [
          {
            "type": "_types.List",
            "items": {
              "type": "_types.Unknown"
            }
          },
          {
            "type": "_types.String"
          }
        ]
      }
    },
    "implementation": {
      "javascript": {
        "code": "if (Array.isArray($$args.input)) {\n  return $$args.input.slice().reverse();\n} else if (typeof $$args.input === 'string') {\n  return $$args.input.split('').reverse().join('');\n} else {\n  throw new Error('Unsupported type');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Union",
      "description": "The reversed list or string.",
      "options": [
        {
          "type": "_types.List",
          "items": {
            "type": "_types.Unknown"
          }
        },
        {
          "type": "_types.String"
        }
      ]
    },
    "tests": {
      "reverseString": {
        "description": "Reverse a string.",
        "input": {
          "input": "hello"
        },
        "expected": "olleh"
      },
      "reverseList": {
        "description": "Reverse a list.",
        "input": {
          "input": [1, 2, 3, 4, 5]
        },
        "expected": [5, 4, 3, 2, 1]
      },
      "reverseEmptyString": {
        "description": "Reverse an empty string.",
        "input": {
          "input": ""
        },
        "expected": ""
      },
      "reverseEmptyList": {
        "description": "Reverse an empty list.",
        "input": {
          "input": []
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.String.ReverseLookup",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the first key from a dictionary that matches the given value.",
    "parameters": {
      "dict": {
        "type": "_types.Dictionary",
        "description": "The dictionary to search for the matching key."
      },
      "value": {
        "type": "_types.String",
        "description": "The value to find in the dictionary."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = null;\nfor (const [key, val] of Object.entries($$args.dict)) {\n  if (val === $$args.value) {\n    result = key;\n    break;\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The first matching key."
    },
    "tests": {
      "reverseLookupSimple": {
        "description": "Find the first key that matches a simple value.",
        "input": {
          "dict": {
            "a": "hello",
            "b": "world"
          },
          "value": "hello"
        },
        "expected": "a"
      },
      "reverseLookupMultiple": {
        "description": "Find the first key that matches one of multiple values.",
        "input": {
          "dict": {
            "a": "hello",
            "b": "goodbye",
            "c": "hello"
          },
          "value": "hello"
        },
        "expected": "a"
      },
      "reverseLookupNoMatch": {
        "description": "Attempt to find a matching key when no match is found.",
        "input": {
          "dict": {
            "a": "hello",
            "b": "world"
          },
          "value": "goodbye"
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.Dictionary.ReverseLookupAll",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns all keys that have the given value in a dictionary.",
    "parameters": {
      "dictionary": {
        "type": "_types.Dictionary",
        "description": "The input dictionary to search."
      },
      "value": {
        "type": "_types.String",
        "description": "The value to look for in the dictionary."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = [];\nObject.keys($$args.dictionary).forEach((k) => {\n  if ($$args.dictionary[k] === $$args.value) {\n    result.push(k);\n  }\n});\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A list of all keys that have the given value in the dictionary."
    },
    "tests": {
      "reverseLookupAllSimple": {
        "description": "Find multiple matches.",
        "input": {
          "dictionary": {
            "a": "x",
            "b": "y",
            "c": "x"
          },
          "value": "x"
        },
        "expected": ["a", "c"]
      },
      "reverseLookupAllNoMatch": {
        "description": "No matches found in the dictionary.",
        "input": {
          "dictionary": {
            "a": "x",
            "b": "y"
          },
          "value": "z"
        },
        "expected": []
      },
      "reverseLookupAllSingleMatch": {
        "description": "A single match found in the dictionary.",
        "input": {
          "dictionary": {
            "a": "x",
            "b": "y",
            "c": "x"
          },
          "value": "y"
        },
        "expected": ["b"]
      }
    }
  },
  {
    "define": "_functions.String.RightPad",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Pads the given string to a specified length by appending a specified character from the right.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The original text to pad."
      },
      "maxLength": {
        "type": "_types.Number",
        "description": "The maximum length of the padded text."
      },
      "padChar": {
        "type": "_types.String",
        "description": "The character to use for padding."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let result = $$args.text;\nif ($$args.maxLength > $$args.text.length) {\n  result += new Array($$args.maxLength - $$args.text.length + 1).join($$args.padChar);\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The padded text."
    },
    "tests": {
      "rightPadSimple": {
        "description": "Pad a short string.",
        "input": {
          "text": "hello",
          "maxLength": 10,
          "padChar": "-"
        },
        "expected": "hello-----"
      },
      "rightPadLonger": {
        "description": "Pad a longer string.",
        "input": {
          "text": "long long string",
          "maxLength": 20,
          "padChar": "*"
        },
        "expected": "long long string****"
      },
      "rightPadNoPadding": {
        "description": "No padding needed.",
        "input": {
          "text": "short",
          "maxLength": 5,
          "padChar": "^"
        },
        "expected": "short"
      }
    }
  },
  {
    "define": "_functions.String.RightStrip",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes whitespace from the right side of a string.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The original text to strip whitespace from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.replace(/\\s+$/g, '');\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The input string with whitespace removed from the right side."
    },
    "tests": {
      "rightStripSimple": {
        "description": "Remove whitespace from the end of a simple string.",
        "input": {
          "text": " hello world"
        },
        "expected": " hello world"
      },
      "rightStripMultiWhitespace": {
        "description": "Remove multiple whitespace characters from the end of a string.",
        "input": {
          "text": "   hello   "
        },
        "expected": "   hello"
      },
      "rightStripNoWhitespaces": {
        "description": "Attempt to remove whitespace when none is present.",
        "input": {
          "text": "hello world"
        },
        "expected": "hello world"
      }
    }
  },
  {
    "define": "_functions.Math.Round",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Rounds a number to a specified number of decimal places.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to round."
      },
      "decimals": {
        "type": "_types.Number",
        "description": "The number of decimal places to round to."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const factor = Math.pow(10, $$args.decimals);\nreturn Math.round($$args.number * factor) / factor;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The rounded number."
    },
    "tests": {
      "roundToZeroDecimals": {
        "description": "Round a number to zero decimal places.",
        "input": {
          "number": 3.14159,
          "decimals": 0
        },
        "expected": 3
      },
      "roundToTwoDecimals": {
        "description": "Round a number to two decimal places.",
        "input": {
          "number": 3.14159,
          "decimals": 2
        },
        "expected": 3.14
      },
      "roundNegativeNumber": {
        "description": "Round a negative number to one decimal place.",
        "input": {
          "number": -2.71828,
          "decimals": 1
        },
        "expected": -2.7
      },
      "roundToZeroDecimalsUp": {
        "description": "Round a number that rounds up to zero decimal places.",
        "input": {
          "number": 2.6,
          "decimals": 0
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.Math.Saturate",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Saturates a value to be within the range of [0, 1].",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to saturate."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.min(1, Math.max(0, $$args.value));\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The saturated value."
    },
    "tests": {
      "saturateZero": {
        "description": "Saturate a value of 0.",
        "input": {
          "value": 0
        },
        "expected": 0
      },
      "saturateOne": {
        "description": "Saturate a value of 1.",
        "input": {
          "value": 1
        },
        "expected": 1
      },
      "saturateLessThanZero": {
        "description": "Saturate a negative value to 0.",
        "input": {
          "value": -1
        },
        "expected": 0
      },
      "saturateGreaterThanOne": {
        "description": "Saturate a value greater than 1 to 1.",
        "input": {
          "value": 2
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.Saturation",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Saturates the input value to a range of [0, 1].",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The value to be saturated."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.min(Math.max($$args.value, 0), 1);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The saturated value in the range [0, 1]."
    },
    "tests": {
      "saturationZero": {
        "description": "Saturate a value of 0.",
        "input": {
          "value": 0
        },
        "expected": 0
      },
      "saturationOne": {
        "description": "Saturate a value of 1.",
        "input": {
          "value": 1
        },
        "expected": 1
      },
      "saturationLessThanZero": {
        "description": "Saturate a value less than 0.",
        "input": {
          "value": -0.5
        },
        "expected": 0
      },
      "saturationGreaterThanOne": {
        "description": "Saturate a value greater than 1.",
        "input": {
          "value": 2
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.Sech",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the hyperbolic secant of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the hyperbolic secant of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return 1 / Math.cosh($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hyperbolic secant of the angle."
    },
    "tests": {
      "sechZero": {
        "description": "Calculate the hyperbolic secant of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 1
      },
      "sechPiOverTwo": {
        "description": "Calculate the hyperbolic secant of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 0.3985368153383867
      },
      "sechPi": {
        "description": "Calculate the hyperbolic secant of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": 0.08626673833405443
      }
    }
  },
  {
    "define": "_functions.List.Sequence",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new sequence by selecting the items starting at the given Start index and ending at the given End index.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to slice."
      },
      "start": {
        "type": "_types.Number",
        "description": "The index of the first item."
      },
      "end": {
        "type": "_types.Number",
        "description": "The index where the range ends, not including the item at this index. Negative index will be calculated from the end of the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.end < 0) {\n  $$args.end = $$args.input.length + $$args.end;\n}\nreturn $$args.input.slice($$args.start, $$args.end);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The new sequence."
    },
    "tests": {
      "sequenceSimple": {
        "description": "Slice the list with start and end indices.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": 1,
          "end": 3
        },
        "expected": ["b", "c"]
      },
      "sequenceNegativeEndIndex": {
        "description": "Use a negative end index to slice from the end of the list.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": 0,
          "end": -1
        },
        "expected": ["a", "b", "c"]
      }
    }
  },
  {
    "define": "_functions.Math.SeriesSum",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the sum of a series using the given formula.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The list of numbers to sum."
      },
      "start": {
        "type": "_types.Number",
        "description": "The starting index of the range to sum (inclusive)."
      },
      "end": {
        "type": "_types.Number",
        "description": "The ending index of the range to sum (exclusive). A negative index is calculated from the end of the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let sum = 0;\nfor (let i = $$args.start; i < $$args.end; i++) {\n  sum += $$args.numbers[i];\n}\nreturn sum;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The sum of the series."
    },
    "tests": {
      "seriesSumSimple": {
        "description": "Sum a simple range.",
        "input": {
          "numbers": [1, 2, 3],
          "start": 0,
          "end": 3
        },
        "expected": 6
      },
      "seriesSumNegativeIndex": {
        "description": "Sum a range with a negative index.",
        "input": {
          "numbers": [1, 2, 3],
          "start": 1,
          "end": -1
        },
        "expected": 0
      },
      "seriesSumStartEnd": {
        "description": "Sum a range with non-zero start and end indices.",
        "input": {
          "numbers": [1, 2, 3, 4, 5],
          "start": 2,
          "end": 4
        },
        "expected": 7
      }
    }
  },
  {
    "define": "_functions.String.SetAlpha",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the first character of a string to a specified uppercase alpha-numeric character.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The original text."
      },
      "char": {
        "type": "_types.String",
        "description": "The uppercase alpha-numeric character to set as the first character."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.replace(/^.*$/, $$args.char + $$args.text.slice(1));\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The new text with the first character changed."
    },
    "tests": {
      "setAlphaSimple": {
        "description": "Set the first character to a simple alpha-numeric character.",
        "input": {
          "text": "hello",
          "char": "X"
        },
        "expected": "Xello"
      },
      "setAlphaMultipleCharacters": {
        "description": "Set the first character to a multi-character string.",
        "input": {
          "text": "example",
          "char": "ThisIsA"
        },
        "expected": "ThisIsAxample"
      }
    }
  },
  {
    "define": "_functions.Any.SetGreen",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Changes the color of a given object to green.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The object whose color is changed."
      },
      "newColor": {
        "type": "_types.String",
        "description": "The new color, which in this case is always \"green\"."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.input) {\n  $$args.input.color = \"green\";\n  return $$args.input;\n} else {\n  return null;\n}\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The object with its color changed to green."
    },
    "tests": {
      "setGreenObject": {
        "description": "Change the color of an existing object.",
        "input": {
          "input": {
            "color": "blue"
          },
          "newColor": ""
        },
        "expected": {
          "color": "green"
        }
      }
    }
  },
  {
    "define": "_functions.Math.SetHue",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the hue of a color.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The new hue to set."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.value;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hue of the color."
    },
    "tests": {
      "setHueZeroToSixty": {
        "description": "Set the hue to 30 degrees.",
        "input": {
          "value": 0.5
        },
        "expected": 0.5
      },
      "setHueSeventyToNinety": {
        "description": "Set the hue to 80 degrees.",
        "input": {
          "value": 0.8
        },
        "expected": 0.8
      }
    }
  },
  {
    "define": "_functions.Dictionary.SetItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the value of a key in a dictionary.",
    "parameters": {
      "dict": {
        "type": "_types.Dictionary",
        "description": "The dictionary to set the item in."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to set the value for."
      },
      "value": {
        "type": "_types.Any",
        "description": "The new value to set for the key."
      }
    },
    "implementation": {
      "javascript": {
        "code": "$$args.dict[$$args.key] = $$args.value;\nreturn $$args.dict;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The dictionary with the new item set."
    },
    "tests": {
      "setItemSimple": {
        "description": "Set a simple key-value pair.",
        "input": {
          "dict": {},
          "key": "foo",
          "value": 42
        },
        "expected": {
          "foo": 42
        }
      },
      "setItemExistingKey": {
        "description": "Update an existing key's value.",
        "input": {
          "dict": {
            "foo": 1
          },
          "key": "foo",
          "value": 2
        },
        "expected": {
          "foo": 2
        }
      },
      "setItemNewKey": {
        "description": "Set a new key-value pair.",
        "input": {
          "dict": {
            "bar": 1
          },
          "key": "baz",
          "value": 42
        },
        "expected": {
          "baz": 42,
          "bar": 1
        }
      }
    }
  },
  {
    "define": "_functions.List.SetItemAt",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the item at the given index in the list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to modify."
      },
      "index": {
        "type": "_types.Number",
        "description": "The index where the item will be set."
      },
      "value": {
        "type": "_types.Any",
        "description": "The new item to set at the specified index."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = $$args.input.slice();  // Create a copy of the input list\nconst adjustedIndex = $$args.index < 0 ? $$args.input.length + $$args.index : $$args.index;\nresult.splice(adjustedIndex, 1, $$args.value);\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The modified list with the item set at the specified index."
    },
    "tests": {
      "setItemAtIndexZero": {
        "description": "Set an item at the first index.",
        "input": {
          "input": ["a", "b", "c"],
          "index": 0,
          "value": "d"
        },
        "expected": ["d", "b", "c"]
      },
      "setItemAtMiddle": {
        "description": "Set an item in the middle of a list.",
        "input": {
          "input": ["a", "b", "c", "d", "e"],
          "index": 2,
          "value": "f"
        },
        "expected": ["a", "b", "f", "d", "e"]
      },
      "setItemAtEnd": {
        "description": "Set an item at the end of a list.",
        "input": {
          "input": ["a", "b", "c"],
          "index": -1,
          "value": "d"
        },
        "expected": ["a", "b", "d"]
      },
      "setItemAtNegativeIndex": {
        "description": "Set an item at a negative index.",
        "input": {
          "input": ["a", "b", "c"],
          "index": -2,
          "value": "d"
        },
        "expected": ["a", "d", "c"]
      }
    }
  },
  {
    "define": "_functions.Dictionary.SetKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the value of a key in a dictionary.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The dictionary to set the key and value for."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to set in the dictionary."
      },
      "value": {
        "type": "_types.Any",
        "description": "The value to set for the given key."
      }
    },
    "implementation": {
      "javascript": {
        "code": "$$args.input[$$args.key] = $$args.value;\nreturn $$args.input;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The updated dictionary with the new key-value pair."
    },
    "tests": {
      "setKeySimple": {
        "description": "Set a simple key-value pair.",
        "input": {
          "input": {},
          "key": "name",
          "value": "John"
        },
        "expected": {
          "name": "John"
        }
      },
      "setKeyExisting": {
        "description": "Update an existing key's value.",
        "input": {
          "input": {
            "name": "Jane"
          },
          "key": "name",
          "value": "John"
        },
        "expected": {
          "name": "John"
        }
      },
      "setKeyNonExisting": {
        "description": "Set a new key-value pair that doesn't exist.",
        "input": {
          "input": {},
          "key": "age",
          "value": 30
        },
        "expected": {
          "age": 30
        }
      }
    }
  },
  {
    "define": "_functions.Math.SetRed",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the color of an object to red.",
    "parameters": {
      "obj": {
        "type": "_types.Any",
        "description": "The object to set the color for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if ($$args.obj.style) {\n  $$args.obj.style.color = \"red\";\n} else {\n  $$args.obj.style = { color: \"red\" };\n}\nreturn $$args.obj;\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The object with its color set to red."
    },
    "tests": {
      "setRedSimple": {
        "description": "Set the color of a simple object.",
        "input": {
          "obj": {
            "id": 1,
            "text": "hello"
          }
        },
        "expected": {
          "id": 1,
          "text": "hello",
          "style": {
            "color": "red"
          }
        }
      },
      "setRedObjectWithColor": {
        "description": "Set the color of an object that already has a color property.",
        "input": {
          "obj": {
            "id": 1,
            "text": "hello",
            "style": {
              "color": "blue"
            }
          }
        },
        "expected": {
          "id": 1,
          "text": "hello",
          "style": {
            "color": "red"
          }
        }
      }
    }
  },
  {
    "define": "_functions.Math.SetSaturation",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Adjusts the color saturation to a given value.",
    "parameters": {
      "hue": {
        "type": "_types.Number",
        "description": "The hue of the color."
      },
      "saturation": {
        "type": "_types.Number",
        "description": "The desired saturation level (0-1)."
      },
      "lightness": {
        "type": "_types.Number",
        "description": "The lightness of the color (0-1)."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hslToString(h, s, l) {\n  return `hsl(${(h * 360).toFixed(0)}, ${(s * 100).toFixed(0)}%, ${(l * 100).toFixed(0)}%)`;\n}\n\nreturn hslToString($$args.hue, $$args.saturation, 0.5);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The new color with adjusted saturation."
    },
    "tests": {
      "setSaturationSimple": {
        "description": "Adjust the saturation to a simple value.",
        "input": {
          "hue": 0.5,
          "saturation": 0.7,
          "lightness": 0.5
        },
        "expected": "hsl(180, 70%, 50%)"
      },
      "setSaturationHigh": {
        "description": "Adjust the saturation to a high value.",
        "input": {
          "hue": 0.25,
          "saturation": 1,
          "lightness": 0.5
        },
        "expected": "hsl(90, 100%, 50%)"
      },
      "setSaturationLow": {
        "description": "Adjust the saturation to a low value.",
        "input": {
          "hue": 0.75,
          "saturation": 0.1,
          "lightness": 0.5
        },
        "expected": "hsl(270, 10%, 50%)"
      }
    }
  },
  {
    "define": "_functions.Date.SetTimezone",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sets the timezone for a given date.",
    "parameters": {
      "date": {
        "type": "_types.Date",
        "description": "The date to set the timezone for, in ISO format."
      },
      "timezone": {
        "type": "_types.String",
        "description": "The timezone to set, in the format \"HH:MM\"."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function setTimezone(date, timezone) {\n  let [hours, minutes] = timezone.split(':').map(Number);\n  const dateObj = new Date(date);\n  \n  // Adjust the timezone offset\n  dateObj.setUTCHours(dateObj.getUTCHours() + hours);\n  dateObj.setUTCMinutes(dateObj.getUTCMinutes() + minutes);\n  \n  // Format the date back to ISO string without timezone information\n  return dateObj.toISOString().replace('Z', '');\n}\n\nreturn setTimezone($$args.date, $$args.timezone);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The date with the specified timezone."
    },
    "tests": {
      "setTimezoneSimple": {
        "description": "Set a simple timezone.",
        "input": {
          "date": "2022-01-01T00:00:00.000Z",
          "timezone": "05:30"
        },
        "expected": "2022-01-01T05:30:00.000"
      },
      "setTimezoneComplex": {
        "description": "Set a complex timezone with multiple hours and minutes.",
        "input": {
          "date": "2022-01-01T00:00:00.000Z",
          "timezone": "14:45"
        },
        "expected": "2022-01-01T14:45:00.000"
      },
      "setTimezoneNegativeOffset": {
        "description": "Set a timezone with a negative offset.",
        "input": {
          "date": "2022-01-01T00:00:00.000Z",
          "timezone": "-03:00"
        },
        "expected": "2021-12-31T21:00:00.000"
      }
    }
  },
  {
    "define": "_functions.Math.ShiftHue",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Shifts the hue of a color by a given angle.",
    "parameters": {
      "hue": {
        "type": "_types.Number",
        "description": "The initial hue to shift."
      },
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to shift the hue by."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function radiansToDegrees(radians) {\n  return radians * (180 / Math.PI);\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * (Math.PI / 180);\n}\n\nlet hueInDegrees = radiansToDegrees($$args.hue);\nlet angleInDegrees = radiansToDegrees($$args.angle);\n\nlet shiftedHue = (hueInDegrees + angleInDegrees) % 360;\nif (shiftedHue < 0) shiftedHue += 360;\n\nreturn degreesToRadians(shiftedHue);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The shifted hue."
    },
    "tests": {
      "shiftHueZero": {
        "description": "Shift the hue by 0 radians.",
        "input": {
          "hue": 0,
          "angle": 0
        },
        "expected": 0
      },
      "shiftHuePiOverTwo": {
        "description": "Shift the hue by Ï€/2 radians.",
        "input": {
          "hue": 1.5707963267948966,
          "angle": 1.5707963267948966
        },
        "expected": 3.141592653589793
      },
      "shiftHueMultipleAngles": {
        "description": "Shift the hue by multiple angles.",
        "input": {
          "hue": 0.5,
          "angle": 2.0943951023931953
        },
        "expected": 2.594395102393195
      }
    }
  },
  {
    "define": "_functions.Math.Shuffle",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Randomly shuffles the elements of a list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to shuffle."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const shuffled = $$args.input.slice();\nfor (let i = shuffled.length - 1; i > 0; i--) {\n  const j = Math.floor(Math.random() * (i + 1));\n  [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n}\nreturn shuffled;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The shuffled list."
    },
    "tests": {
      "shuffleEmptyList": {
        "description": "Shuffle an empty list.",
        "input": {
          "input": []
        },
        "expected": []
      },
      "shuffleSingleElementList": {
        "description": "Shuffle a list with a single element.",
        "input": {
          "input": ["a"]
        },
        "expected": ["a"]
      }
    }
  },
  {
    "define": "_functions.Math.Sin",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the sine of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the sine of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.sin($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The sine of the angle."
    },
    "tests": {
      "sinZero": {
        "description": "Calculate the sine of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 0
      },
      "sinPiOverTwo": {
        "description": "Calculate the sine of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 1
      },
      "sinPi": {
        "description": "Calculate the sine of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": 1.2246467991473532e-16
      }
    }
  },
  {
    "define": "_functions.String.Slice",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Extracts a portion of a list or string.",
    "parameters": {
      "input": {
        "type": "_types.String",
        "description": "The string to slice."
      },
      "start": {
        "type": "_types.Number",
        "description": "The start index for slicing."
      },
      "end": {
        "type": "_types.Number",
        "description": "The end index for slicing."
      }
    },
    "implementation": {
      "javascript": {
        "code": "if (Array.isArray($$args.input)) {\n  return $$args.input.slice($$args.start, $$args.end);\n} else if (typeof $$args.input === 'string') {\n  return $$args.input.substring($$args.start, $$args.end);\n} else {\n  throw new Error('Unsupported type');\n}\n"
      }
    },
    "returns": {
      "type": "_types.Union",
      "description": "The sliced portion of the list or string.",
      "options": [
        {
          "type": "_types.List",
          "items": {
            "type": "_types.Unknown"
          }
        },
        {
          "type": "_types.String"
        }
      ]
    },
    "tests": {
      "sliceString": {
        "description": "Slice a portion of a string.",
        "input": {
          "input": "hello world",
          "start": 0,
          "end": 5
        },
        "expected": "hello"
      },
      "sliceList": {
        "description": "Slice a portion of a list.",
        "input": {
          "input": [1, 2, 3, 4, 5],
          "start": 1,
          "end": 3
        },
        "expected": [2, 3]
      },
      "sliceStringEnd": {
        "description": "Slice a portion of a string from the middle to the end.",
        "input": {
          "input": "hello world",
          "start": 6,
          "end": 11
        },
        "expected": "world"
      },
      "sliceListEnd": {
        "description": "Slice a portion of a list from the middle to the end.",
        "input": {
          "input": [1, 2, 3, 4, 5],
          "start": 2,
          "end": 5
        },
        "expected": [3, 4, 5]
      }
    }
  },
  {
    "define": "_functions.String.SnakeCase",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts a string to snake_case.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to convert to snake_case."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string\n  .replace(/\\s+/g, '_')\n  .replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)\n  .replace(/^_/, '')\n  .toLowerCase();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The snake_cased string."
    },
    "tests": {
      "snakeCaseSingleWord": {
        "description": "Convert a single word to snake_case.",
        "input": {
          "string": "hello"
        },
        "expected": "hello"
      },
      "snakeCaseMultipleWords": {
        "description": "Convert multiple words to snake_case.",
        "input": {
          "string": "hello world"
        },
        "expected": "hello_world"
      },
      "snakeCaseCamelCase": {
        "description": "Convert a camelCase string to snake_case.",
        "input": {
          "string": "helloWorldTest"
        },
        "expected": "hello_world_test"
      }
    }
  },
  {
    "define": "_functions.Math.Sort",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sorts a list of items in ascending order.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to sort."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input.slice().sort((a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  return a.toString().localeCompare(b.toString());\n});\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The sorted list."
    },
    "tests": {
      "sortNumbers": {
        "description": "Sort a list of numbers.",
        "input": {
          "input": [3, 1, 2]
        },
        "expected": [1, 2, 3]
      },
      "sortStrings": {
        "description": "Sort a list of strings.",
        "input": {
          "input": ["c", "b", "a"]
        },
        "expected": ["a", "b", "c"]
      },
      "sortMixed": {
        "description": "Sort a list with mixed types.",
        "input": {
          "input": [3, "2", "a", 1]
        },
        "expected": [1, "2", 3, "a"]
      },
      "sortEmptyList": {
        "description": "Sort an empty list.",
        "input": {
          "input": []
        },
        "expected": []
      },
      "sortSingleElementList": {
        "description": "Sort a list with a single element.",
        "input": {
          "input": [5]
        },
        "expected": [5]
      }
    }
  },
  {
    "define": "_functions.List.SortByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sorts a list of key-value pairs by their keys.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to sort."
      },
      "order": {
        "type": "_types.String",
        "description": "The order in which to sort the list. Can be either \"asc\" or \"desc\"."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const order = $$args.order.toLowerCase();\nif (order === \"asc\") {\n  return $$args.input.slice().sort((a, b) => a[0].localeCompare(b[0]));\n} else if (order === \"desc\") {\n  return $$args.input.slice().sort((a, b) => b[0].localeCompare(a[0]));\n} else {\n  throw new Error('Invalid sort order');\n}\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The sorted list of key-value pairs."
    },
    "tests": {
      "sortByKeyAsc": {
        "description": "Sort a list in ascending order.",
        "input": {
          "input": [
            ["c", 3],
            ["a", 1],
            ["b", 2]
          ],
          "order": "asc"
        },
        "expected": [
          ["a", 1],
          ["b", 2],
          ["c", 3]
        ]
      },
      "sortByKeyDesc": {
        "description": "Sort a list in descending order.",
        "input": {
          "input": [
            ["c", 3],
            ["a", 1],
            ["b", 2]
          ],
          "order": "desc"
        },
        "expected": [
          ["c", 3],
          ["b", 2],
          ["a", 1]
        ]
      },
      "sortByKeyEmptyList": {
        "description": "Sort an empty list.",
        "input": {
          "input": [],
          "order": "asc"
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.List.SortByKeyCaseSensitive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sorts a list of key-value pairs based on the keys in a case-sensitive manner.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list of key-value pairs to sort."
      },
      "order": {
        "type": "_types.String",
        "description": "The order to sort the list. Can be either \"asc\" or \"desc\"."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const sorted = $$args.input.slice();\nif ($$args.order === \"asc\") {\n  return sorted.sort((a, b) => a[0].localeCompare(b[0]));\n} else {\n  return sorted.sort((a, b) => b[0].localeCompare(a[0]));\n}\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The sorted list of key-value pairs."
    },
    "tests": {
      "sortByKeyCaseSensitiveAsc": {
        "description": "Sort a list in ascending order.",
        "input": {
          "input": [
            ["c", "value1"],
            ["a", "value2"],
            ["b", "value3"]
          ],
          "order": "asc"
        },
        "expected": [
          ["a", "value2"],
          ["b", "value3"],
          ["c", "value1"]
        ]
      },
      "sortByKeyCaseSensitiveDesc": {
        "description": "Sort a list in descending order.",
        "input": {
          "input": [
            ["c", "value1"],
            ["a", "value2"],
            ["b", "value3"]
          ],
          "order": "desc"
        },
        "expected": [
          ["c", "value1"],
          ["b", "value3"],
          ["a", "value2"]
        ]
      },
      "sortByKeyCaseSensitiveMixedCase": {
        "description": "Sort a list with mixed case keys.",
        "input": {
          "input": [
            ["c", "value1"],
            ["A", "value2"],
            ["b", "value3"]
          ],
          "order": "asc"
        },
        "expected": [
          ["A", "value2"],
          ["b", "value3"],
          ["c", "value1"]
        ]
      }
    }
  },
  {
    "define": "_functions.List.SortCaseSensitive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Sorts a list of strings in a case-sensitive manner.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to sort."
      },
      "order": {
        "type": "_types.String",
        "description": "The sorting order, either \"asc\" for ascending or \"desc\" for descending."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const sorted = $$args.input.slice();\nif ($$args.order === 'asc') {\n  return sorted.sort((a, b) => a.localeCompare(b));\n} else if ($$args.order === 'desc') {\n  return sorted.sort((a, b) => b.localeCompare(a));\n} else {\n  throw new Error('Invalid order. Must be either \"asc\" or \"desc\".');\n}\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The sorted list."
    },
    "tests": {
      "sortCaseSensitiveAsc": {
        "description": "Sort a list of strings in ascending case-sensitive manner.",
        "input": {
          "input": ["hello", "world", "abc", "def"],
          "order": "asc"
        },
        "expected": ["abc", "def", "hello", "world"]
      },
      "sortCaseSensitiveDesc": {
        "description": "Sort a list of strings in descending case-sensitive manner.",
        "input": {
          "input": ["hello", "world", "abc", "def"],
          "order": "desc"
        },
        "expected": ["world", "hello", "def", "abc"]
      },
      "sortCaseSensitiveMixed": {
        "description": "Sort a list of strings with mixed case in ascending order.",
        "input": {
          "input": ["hello", "World", "abc", "Def"],
          "order": "asc"
        },
        "expected": ["abc", "Def", "hello", "World"]
      },
      "sortCaseSensitiveEmpty": {
        "description": "Sort an empty list.",
        "input": {
          "input": [],
          "order": "asc"
        },
        "expected": []
      },
      "sortCaseSensitiveSingle": {
        "description": "Sort a list with a single element.",
        "input": {
          "input": ["hello"],
          "order": "asc"
        },
        "expected": ["hello"]
      }
    }
  },
  {
    "define": "_functions.List.Splice",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Inserts the given items at the specified position and/or removes the given number of elements from that position.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to be modified."
      },
      "start": {
        "type": "_types.Number",
        "description": "Index where the operation starts."
      },
      "removalCount": {
        "type": "_types.Number",
        "description": "The number of items to remove from the specified position."
      },
      "newItems": {
        "type": "_types.List",
        "description": "The items to insert at the specified position."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const result = $$args.input.slice();\nif ($$args.removalCount !== undefined) {\n  result.splice($$args.start, $$args.removalCount);\n}\nif ($$args.newItems && $$args.newItems.length > 0) {\n  result.splice($$args.start, 0, ...$$args.newItems);\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The modified list."
    },
    "tests": {
      "spliceInsert": {
        "description": "Insert items at the specified position.",
        "input": {
          "input": ["a", "b", "c"],
          "start": 2,
          "newItems": ["d", "e"]
        },
        "expected": ["a", "b", "d", "e", "c"]
      },
      "spliceRemove": {
        "description": "Remove the given number of items from the specified position.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": 1,
          "removalCount": 2
        },
        "expected": ["a", "d"]
      },
      "spliceInsertAndRemove": {
        "description": "Insert and remove items at the specified position.",
        "input": {
          "input": ["a", "b", "c", "d"],
          "start": 1,
          "removalCount": 1,
          "newItems": ["e", "f"]
        },
        "expected": ["a", "e", "f", "c", "d"]
      },
      "spliceInsertAtStart": {
        "description": "Insert items at the start of the list.",
        "input": {
          "input": ["x", "y", "z"],
          "start": 0,
          "newItems": ["a", "b"]
        },
        "expected": ["a", "b", "x", "y", "z"]
      },
      "spliceRemoveFromEnd": {
        "description": "Remove items from the end of the list.",
        "input": {
          "input": ["x", "y", "z"],
          "start": 1,
          "removalCount": 2
        },
        "expected": ["x"]
      },
      "spliceInsertWithNegativeStart": {
        "description": "Insert items at a negative index position.",
        "input": {
          "input": ["x", "y", "z"],
          "start": -1,
          "newItems": ["a", "b"]
        },
        "expected": ["x", "y", "a", "b", "z"]
      }
    }
  },
  {
    "define": "_functions.String.Split",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Splits a string into an array of substrings using a specified separator",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to split"
      },
      "separator": {
        "type": "_types.String",
        "description": "The separator to split the string with"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.split($$args.separator);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The array of substrings"
    },
    "tests": {
      "noSeparator": {
        "description": "Test with no separator",
        "input": {
          "string": "hello",
          "separator": " "
        },
        "expected": ["hello"]
      },
      "oneSeparator": {
        "description": "Test with one separator",
        "input": {
          "string": "hello world",
          "separator": " "
        },
        "expected": ["hello", "world"]
      },
      "multipleSeparators": {
        "description": "Test with multiple separators",
        "input": {
          "string": "hello world world",
          "separator": " "
        },
        "expected": ["hello", "world", "world"]
      }
    }
  },
  {
    "define": "_functions.Math.Sqrt",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the square root of a number.",
    "parameters": {
      "value": {
        "type": "_types.Number",
        "description": "The number to calculate the square root of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.sqrt($$args.value);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The square root of the input value."
    },
    "tests": {
      "sqrtOne": {
        "description": "Calculate the square root of 1.",
        "input": {
          "value": 1
        },
        "expected": 1
      },
      "sqrtFour": {
        "description": "Calculate the square root of 4.",
        "input": {
          "value": 4
        },
        "expected": 2
      },
      "sqrtNine": {
        "description": "Calculate the square root of 9.",
        "input": {
          "value": 9
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.Math.SqrtPi",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the square root of pi.",
    "parameters": {
      "none": {
        "type": "_types.None",
        "description": "No parameters required."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.sqrt(Math.PI);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The square root of pi."
    },
    "tests": {
      "sqrtPi": {
        "description": "Test the square root of pi.",
        "expected": 1.7724538509055159
      }
    }
  },
  {
    "define": "_functions.Math.SquareRoot",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculate the square root of a number.",
    "parameters": {
      "number": {
        "type": "_types.Number",
        "description": "The number to calculate the square root of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.sqrt($$args.number);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The square root of the number."
    },
    "tests": {
      "squareRoot": {
        "description": "Calculate the square root of a number.",
        "input": {
          "number": 9
        },
        "expected": 3
      }
    }
  },
  {
    "define": "_functions.String.StartsWith",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a string starts with a specified substring.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to check."
      },
      "substring": {
        "type": "_types.String",
        "description": "The substring to look for at the start of the string."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.startsWith($$args.substring);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the string starts with the specified substring, otherwise false."
    },
    "tests": {
      "startsWithTrue": {
        "description": "String starts with the specified substring.",
        "input": {
          "string": "hello world",
          "substring": "hello"
        },
        "expected": true
      },
      "startsWithFalse": {
        "description": "String does not start with the specified substring.",
        "input": {
          "string": "hello world",
          "substring": "world"
        },
        "expected": false
      },
      "startsWithEmptySubstring": {
        "description": "Check when substring is empty.",
        "input": {
          "string": "hello world",
          "substring": ""
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.String.Upper",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts a given string to uppercase.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The input string to convert to uppercase."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.toUpperCase();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The input string converted to uppercase."
    },
    "tests": {
      "upperSimple": {
        "description": "Convert a simple string to uppercase.",
        "input": {
          "text": "hello"
        },
        "expected": "HELLO"
      },
      "upperMultiWord": {
        "description": "Convert a multi-word string to uppercase.",
        "input": {
          "text": "hello world"
        },
        "expected": "HELLO WORLD"
      }
    }
  },
  {
    "define": "_functions.String.StripHTMLTags",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes HTML tags from a given text.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The text to strip of HTML tags."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const cleanedText = $$args.text.replace(/<[^>]*>/g, '');\nreturn cleanedText;\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The text with HTML tags removed."
    },
    "tests": {
      "stripHtmlTagsSimple": {
        "description": "Remove a single HTML tag.",
        "input": {
          "text": "<p>Hello</p>"
        },
        "expected": "Hello"
      },
      "stripHtmlTagsMultiple": {
        "description": "Remove multiple HTML tags.",
        "input": {
          "text": "<p>Hello <span>World!</span></p>"
        },
        "expected": "Hello World!"
      },
      "stripHtmlTagsNoMatch": {
        "description": "Attempt to remove when no match is found.",
        "input": {
          "text": "hello world"
        },
        "expected": "hello world"
      }
    }
  },
  {
    "define": "_functions.String.Substring",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a subset of characters in the original string, starting from the specified Start index and extending to the specified End index.",
    "parameters": {
      "text": {
        "type": "_types.String",
        "description": "The original string."
      },
      "start": {
        "type": "_types.Number",
        "description": "The index at which to start the substring."
      },
      "end": {
        "type": "_types.Number",
        "description": "The index up to which the substring extends, not including the character at this index."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.text.substring($$args.start, $$args.end);\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The subset of characters in the original string."
    },
    "tests": {
      "substringSimple": {
        "description": "Return a simple substring.",
        "input": {
          "text": "hello world",
          "start": 6,
          "end": 10
        },
        "expected": "worl"
      },
      "substringNegativeIndex": {
        "description": "Calculate a negative index from the end of the list.",
        "input": {
          "text": "hello",
          "start": 0,
          "end": -3
        },
        "expected": ""
      },
      "substringEndEqualToStart": {
        "description": "When the End index is equal to the Start index, return an empty string.",
        "input": {
          "text": "hello",
          "start": 2,
          "end": 2
        },
        "expected": ""
      },
      "substringInvalidIndex": {
        "description": "Attempt to access out-of-range indices.",
        "input": {
          "text": "hello",
          "start": 5,
          "end": -1
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.Math.Subtract",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Subtract two numbers.",
    "parameters": {
      "a": {
        "type": "_types.Number",
        "description": "The first number."
      },
      "b": {
        "type": "_types.Number",
        "description": "The second number."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.a - $$args.b;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The difference of the two numbers."
    },
    "tests": {
      "subtractTwo": {
        "description": "Subtract two numbers.",
        "input": {
          "a": 3,
          "b": 2
        },
        "expected": 1
      }
    }
  },
  {
    "define": "_functions.Math.SubtractDuration",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Subtracts a duration from a date.",
    "parameters": {
      "date": {
        "type": "_types.String",
        "description": "The original date in ISO format."
      },
      "duration": {
        "type": "_types.Number",
        "description": "The duration to subtract in seconds."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const date = new Date($$args.date);\nconst newTime = date.getTime() - $$args.duration * 1000;\nreturn new Date(newTime).toISOString();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The date after subtracting the duration in ISO format."
    },
    "tests": {
      "subtractDurationOneSecond": {
        "description": "Subtract one second from a date.",
        "input": {
          "date": "2022-01-01T00:00:00.000Z",
          "duration": 1
        },
        "expected": "2021-12-31T23:59:59.000Z"
      },
      "subtractDurationOneHour": {
        "description": "Subtract one hour from a date.",
        "input": {
          "date": "2022-01-01T02:00:00.000Z",
          "duration": 3600
        },
        "expected": "2022-01-01T01:00:00.000Z"
      }
    }
  },
  {
    "define": "_functions.Math.Sum",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the sum of a list of numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List",
        "description": "The list of numbers to sum.",
        "items": {
          "type": "_types.Number"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.numbers.reduce((sum, curr) => sum + curr, 0);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The sum of the numbers."
    },
    "tests": {
      "sumOfNumbers": {
        "description": "Calculate the sum of a list of numbers.",
        "input": {
          "numbers": [1, 2, 3, 4]
        },
        "expected": 10
      },
      "sumWithNegativeNumbers": {
        "description": "Calculate the sum of a list with negative numbers.",
        "input": {
          "numbers": [10, -5, 3, -2]
        },
        "expected": 6
      },
      "sumEmptyList": {
        "description": "Calculate the sum of an empty list.",
        "input": {
          "numbers": []
        },
        "expected": 0
      },
      "sumSingleNumber": {
        "description": "Calculate the sum of a list with a single number.",
        "input": {
          "numbers": [42]
        },
        "expected": 42
      }
    }
  },
  {
    "define": "_functions.Dictionary.SumByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the sum of values in a dictionary based on the given key.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The dictionary to calculate the sum from."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to sum up the values for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let sum = 0;\nObject.keys($$args.input).forEach((k) => {\n  if (k === $$args.key) {\n    sum += $$args.input[k];\n  }\n});\nreturn sum;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The sum of values for the given key."
    },
    "tests": {
      "sumByKeySimple": {
        "description": "Calculate the sum of a single value.",
        "input": {
          "input": {
            "x": 1
          },
          "key": "x"
        },
        "expected": 1
      },
      "sumByKeyMultipleValues": {
        "description": "Calculate the sum of multiple values with the same key.",
        "input": {
          "input": {
            "x": 2,
            "y": 3,
            "z": 4
          },
          "key": "x"
        },
        "expected": 2
      },
      "sumByKeyNoKey": {
        "description": "Attempt to calculate the sum for a non-existent key.",
        "input": {
          "input": {
            "a": 1,
            "b": 2
          },
          "key": "c"
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Math.SumSquared",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the sum of squares of the given numbers.",
    "parameters": {
      "numbers": {
        "type": "_types.List(Number)",
        "description": "A list of numbers to calculate the sum of squares for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.numbers.map(x => x ** 2).reduce((a, b) => a + b);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The sum of squares of the given numbers."
    },
    "tests": {
      "sumSquaredSingleNumber": {
        "description": "Calculate the sum of squares for a single number.",
        "input": {
          "numbers": [3]
        },
        "expected": 9
      },
      "sumSquaredTwoNumbers": {
        "description": "Calculate the sum of squares for two numbers.",
        "input": {
          "numbers": [2, 4]
        },
        "expected": 20
      },
      "sumSquaredThreeNumbers": {
        "description": "Calculate the sum of squares for three numbers.",
        "input": {
          "numbers": [1, 2, 3]
        },
        "expected": 14
      }
    }
  },
  {
    "define": "_functions.List.SymmetricDifference",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the list of items that are in either of the given lists but not in both.",
    "parameters": {
      "list1": {
        "type": "_types.List",
        "description": "The first list to find the symmetric difference for."
      },
      "list2": {
        "type": "_types.List",
        "description": "The second list to find the symmetric difference for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let set1 = new Set($$args.list1);\nlet set2 = new Set($$args.list2);\nreturn [...set1].filter(x => !set2.has(x)).concat([...set2].filter(x => !set1.has(x)));\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list of items that are in either of the given lists but not in both."
    },
    "tests": {
      "symmetricDifferenceSimple": {
        "description": "Find the symmetric difference between two simple lists.",
        "input": {
          "list1": ["a", "b", "c"],
          "list2": ["d", "e", "f"]
        },
        "expected": ["a", "b", "c", "d", "e", "f"]
      },
      "symmetricDifferenceCommonItems": {
        "description": "Find the symmetric difference when both lists have common items.",
        "input": {
          "list1": ["a", "b", "c", "d"],
          "list2": ["d", "e", "f"]
        },
        "expected": ["a", "b", "c", "e", "f"]
      },
      "symmetricDifferenceNoCommonItems": {
        "description": "Find the symmetric difference when both lists have no common items.",
        "input": {
          "list1": ["a", "b", "c"],
          "list2": ["d", "e", "f"]
        },
        "expected": ["a", "b", "c", "d", "e", "f"]
      },
      "symmetricDifferenceEmptyList": {
        "description": "Find the symmetric difference when one list is empty.",
        "input": {
          "list1": ["a", "b", "c"],
          "list2": []
        },
        "expected": ["a", "b", "c"]
      },
      "symmetricDifferenceBothEmptyLists": {
        "description": "Find the symmetric difference when both lists are empty.",
        "input": {
          "list1": [],
          "list2": []
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.Math.Tan",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the tangent of an angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the tangent of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.tan($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The tangent of the angle."
    },
    "tests": {
      "tanZero": {
        "description": "Calculate the tangent of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 0
      },
      "tanPiOverFour": {
        "description": "Calculate the tangent of Ï€/4 radians.",
        "input": {
          "angle": 0.7853981633974483
        },
        "expected": 0.9999999999999999
      },
      "tanPi": {
        "description": "Calculate the tangent of Ï€ radians.",
        "input": {
          "angle": 3.141592653589793
        },
        "expected": -1.2246467991473532e-16
      }
    }
  },
  {
    "define": "_functions.Math.Tanh",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Calculates the hyperbolic tangent of a given angle (in radians).",
    "parameters": {
      "angle": {
        "type": "_types.Number",
        "description": "The angle in radians to calculate the hyperbolic tangent of."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Math.tanh($$args.angle);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The hyperbolic tangent of the angle."
    },
    "tests": {
      "tanhZero": {
        "description": "Calculate the hyperbolic tangent of 0 radians.",
        "input": {
          "angle": 0
        },
        "expected": 0
      },
      "tanhPiOverFour": {
        "description": "Calculate the hyperbolic tangent of Ï€/4 radians.",
        "input": {
          "angle": 0.7853981633974483
        },
        "expected": 0.6557942026326724
      },
      "tanhPiHalf": {
        "description": "Calculate the hyperbolic tangent of Ï€/2 radians.",
        "input": {
          "angle": 1.5707963267948966
        },
        "expected": 0.9171523356672744
      }
    }
  },
  {
    "define": "_functions.Math.Timestamp",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the current timestamp.",
    "parameters": {
      "none": {
        "type": "_types.Any",
        "description": "No parameters needed."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return new Date().getTime();\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The current timestamp in milliseconds since the Unix epoch (January 1, 1970, 00:00:00 UTC)."
    },
    "tests": null
  },
  {
    "define": "_functions.Number.Timezone",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the timezone offset in hours from UTC.",
    "parameters": {
      "date": {
        "type": "_types.String",
        "description": "The date to get the timezone offset for in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const date = new Date($$args.date);\nconst timezoneOffsetInMinutes = date.getTimezoneOffset();\nconst timezoneOffsetInHours = -timezoneOffsetInMinutes / 60;\nreturn timezoneOffsetInHours === 0 ? 0 : timezoneOffsetInHours;\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The timezone offset in hours from UTC."
    },
    "tests": {
      "timezoneUTC": {
        "description": "Get the timezone offset of a date at UTC.",
        "input": {
          "date": "2022-01-01T00:00:00.000Z"
        },
        "expected": 0
      },
      "timezoneEST": {
        "description": "Get the timezone offset of a date in EST (Eastern Standard Time).",
        "input": {
          "date": "2022-03-15T14:30:00.000Z"
        },
        "expected": 0
      }
    }
  },
  {
    "define": "_functions.Math.ToDegrees",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts an angle from radians to degrees.",
    "parameters": {
      "radians": {
        "type": "_types.Number",
        "description": "The angle in radians to convert to degrees."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.radians * (180 / Math.PI);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The angle in degrees."
    },
    "tests": {
      "radiansToDegreesZero": {
        "description": "Convert 0 radians to degrees.",
        "input": {
          "radians": 0
        },
        "expected": 0
      },
      "radiansToDegreesPiOverTwo": {
        "description": "Convert Ï€/2 radians to degrees.",
        "input": {
          "radians": 1.5707963267948966
        },
        "expected": 90
      },
      "radiansToDegreesPi": {
        "description": "Convert Ï€ radians to degrees.",
        "input": {
          "radians": 3.141592653589793
        },
        "expected": 180
      },
      "radiansToDegreesTwoPi": {
        "description": "Convert 2Ï€ radians to degrees.",
        "input": {
          "radians": 6.283185307179586
        },
        "expected": 360
      }
    }
  },
  {
    "define": "_functions.Math.ToRadians",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts an angle from degrees to radians.",
    "parameters": {
      "degrees": {
        "type": "_types.Number",
        "description": "The angle in degrees to convert to radians."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.degrees * (Math.PI / 180);\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The angle in radians."
    },
    "tests": {
      "degreesToRadiansZero": {
        "description": "Convert 0 degrees to radians.",
        "input": {
          "degrees": 0
        },
        "expected": 0
      },
      "degreesToRadiansNinety": {
        "description": "Convert 90 degrees to radians.",
        "input": {
          "degrees": 90
        },
        "expected": 1.5707963267948966
      },
      "degreesToRadians180": {
        "description": "Convert 180 degrees to radians.",
        "input": {
          "degrees": 180
        },
        "expected": 3.141592653589793
      },
      "degreesToRadians360": {
        "description": "Convert 360 degrees to radians.",
        "input": {
          "degrees": 360
        },
        "expected": 6.283185307179586
      }
    }
  },
  {
    "define": "_functions.String.Trim",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes whitespace from the beginning and end of a string",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to trim"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.trim();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The trimmed string"
    },
    "tests": {
      "noWhitespace": {
        "description": "Test with a string with no whitespace",
        "input": {
          "string": "hello"
        },
        "expected": "hello"
      },
      "whitespace": {
        "description": "Test with a string with whitespace",
        "input": {
          "string": "  hello  "
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.String.TrimEnd",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Trims whitespace from the end of a string.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to trim."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.trimEnd();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The trimmed string."
    },
    "tests": {
      "trimEndWhitespace": {
        "description": "Trim whitespace from the end of the string.",
        "input": {
          "string": "hello world   "
        },
        "expected": "hello world"
      },
      "trimEndNoWhitespace": {
        "description": "String with no trailing whitespace.",
        "input": {
          "string": "hello world"
        },
        "expected": "hello world"
      },
      "trimEndEmptyString": {
        "description": "Trim an empty string.",
        "input": {
          "string": ""
        },
        "expected": ""
      }
    }
  },
  {
    "define": "_functions.String.TrimStart",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Trims whitespace from the beginning of a string.",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to trim."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.trimStart();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The trimmed string."
    },
    "tests": {
      "trimStartWhitespace": {
        "description": "Trim whitespace from the beginning of the string.",
        "input": {
          "string": "   hello world"
        },
        "expected": "hello world"
      },
      "trimStartNoWhitespace": {
        "description": "String with no leading whitespace.",
        "input": {
          "string": "hello world"
        },
        "expected": "hello world"
      },
      "trimStartEmptyString": {
        "description": "Trim an empty string.",
        "input": {
          "string": ""
        },
        "expected": ""
      }
    }
  },
  {
    "define": "_functions.String.Concat",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Concatenates multiple strings into one string.",
    "parameters": {
      "inputs": {
        "type": "_types.List(String)",
        "description": "The list of strings to concatenate."
      },
      "separator": {
        "type": "_types.String",
        "description": "The separator between the strings. If not provided, defaults to an empty string."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.inputs.join($$args.separator || '');\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The concatenated string."
    },
    "tests": {
      "concatTwoStrings": {
        "description": "Concatenate two strings with a separator.",
        "input": {
          "inputs": ["hello", "world"],
          "separator": ", "
        },
        "expected": "hello, world"
      },
      "concatThreeStrings": {
        "description": "Concatenate three strings without a separator.",
        "input": {
          "inputs": ["a", "b", "c"]
        },
        "expected": "abc"
      },
      "concatSingleString": {
        "description": "Concatenate a single string with no separator.",
        "input": {
          "inputs": ["hello"]
        },
        "expected": "hello"
      }
    }
  },
  {
    "define": "_functions.List.Union",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Combines two lists into one, removing duplicate values.",
    "parameters": {
      "list1": {
        "type": "_types.List",
        "description": "The first list to combine.",
        "items": {
          "type": "_types.Unknown"
        }
      },
      "list2": {
        "type": "_types.List",
        "description": "The second list to combine.",
        "items": {
          "type": "_types.Unknown"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return [...new Set([...$$args.list1, ...$$args.list2])];\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The combined list with duplicates removed.",
      "items": {
        "type": "_types.Unknown"
      }
    },
    "tests": {
      "unionNoDuplicates": {
        "description": "Union of two lists with no duplicates.",
        "input": {
          "list1": [1, 2, 3],
          "list2": [4, 5, 6]
        },
        "expected": [1, 2, 3, 4, 5, 6]
      },
      "unionWithDuplicates": {
        "description": "Union of two lists with duplicates.",
        "input": {
          "list1": [1, 2, 3],
          "list2": [3, 4, 5]
        },
        "expected": [1, 2, 3, 4, 5]
      },
      "unionEmptyFirst": {
        "description": "Union of an empty first list and a non-empty second list.",
        "input": {
          "list1": [],
          "list2": [1, 2, 3]
        },
        "expected": [1, 2, 3]
      },
      "unionEmptySecond": {
        "description": "Union of a non-empty first list and an empty second list.",
        "input": {
          "list1": [1, 2, 3],
          "list2": []
        },
        "expected": [1, 2, 3]
      }
    }
  },
  {
    "define": "_functions.List.Unique",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes duplicate values from a list.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The list from which to remove duplicate values.",
        "items": {
          "type": "_types.Any"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "return [...new Set($$args.list)];\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list with duplicates removed.",
      "items": {
        "type": "_types.Any"
      }
    },
    "tests": {
      "uniqueWithDuplicates": {
        "description": "Remove duplicates from a list with duplicate values.",
        "input": {
          "list": [1, 2, 2, 3, 4, 4, 5]
        },
        "expected": [1, 2, 3, 4, 5]
      },
      "uniqueNoDuplicates": {
        "description": "List with no duplicate values.",
        "input": {
          "list": [1, 2, 3, 4, 5]
        },
        "expected": [1, 2, 3, 4, 5]
      },
      "uniqueEmptyList": {
        "description": "Remove duplicates from an empty list.",
        "input": {
          "list": []
        },
        "expected": []
      },
      "uniqueMixedTypes": {
        "description": "Remove duplicates from a list with mixed types.",
        "input": {
          "list": [1, "1", 2, "2", 2, 3, "3", "3"]
        },
        "expected": [1, "1", 2, "2", 3, "3"]
      }
    }
  },
  {
    "define": "_functions.Dictionary.UniqueByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new dictionary where each key is unique based on the specified key.",
    "parameters": {
      "input": {
        "type": "_types.Dictionary",
        "description": "The input dictionary to process."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to use for uniqueness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const seen = new Set();\nconst result = {};\nfor (const [k, v] of Object.entries($$args.input)) {\n  if (!seen.has(v)) {\n    seen.add(v);\n    result[$$args.key + v] = v;\n  }\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.Dictionary",
      "description": "The new dictionary with unique keys."
    },
    "tests": {
      "uniqueByKeySimple": {
        "description": "Process a simple input.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "key": "value"
        },
        "expected": {
          "value1": 1,
          "value2": 2,
          "value3": 3
        }
      },
      "uniqueByKeyComplex": {
        "description": "Process a complex input.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4,
            "e": 5
          },
          "key": "letter"
        },
        "expected": {
          "letter1": 1,
          "letter2": 2,
          "letter3": 3,
          "letter4": 4,
          "letter5": 5
        }
      },
      "uniqueByKeyDuplicateValues": {
        "description": "Process an input with duplicate values.",
        "input": {
          "input": {
            "a": 1,
            "b": 2,
            "c": 1,
            "d": 3
          },
          "key": "unique"
        },
        "expected": {
          "unique1": 1,
          "unique2": 2,
          "unique3": 3
        }
      },
      "uniqueByKeyEmptyInput": {
        "description": "Process an empty input.",
        "input": {
          "input": {},
          "key": "empty"
        },
        "expected": {}
      }
    }
  },
  {
    "define": "_functions.String.Uppercase",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Converts a string to uppercase",
    "parameters": {
      "string": {
        "type": "_types.String",
        "description": "The string to convert to uppercase"
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.string.toUpperCase();\n"
      }
    },
    "returns": {
      "type": "_types.String",
      "description": "The uppercase string"
    },
    "tests": {
      "fullLowercase": {
        "description": "Test with a lowercase string",
        "input": {
          "string": "hello"
        },
        "expected": "HELLO"
      },
      "fullUppercase": {
        "description": "Test with an uppercase string",
        "input": {
          "string": "WORLD"
        },
        "expected": "WORLD"
      }
    }
  },
  {
    "define": "_functions.List.Values",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the values of a given list.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to get the values from."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The values of the input list."
    },
    "tests": {
      "valuesSimple": {
        "description": "Get the values of a simple list.",
        "input": {
          "input": [1, 2, 3]
        },
        "expected": [1, 2, 3]
      },
      "valuesEmptyList": {
        "description": "Get the values of an empty list.",
        "input": {
          "input": []
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.List.WithItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Selects the item at the given index.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The input list."
      },
      "index": {
        "type": "_types.Number",
        "description": "The index of the item to select. Negative index will be calculated from the end of the list."
      }
    },
    "implementation": {
      "javascript": {
        "code": "let index = $$args.index;\nif (index < 0) {\n  index = $$args.list.length + index;\n}\nreturn $$args.list[index];\n"
      }
    },
    "returns": {
      "type": "_types.Any",
      "description": "The selected item."
    },
    "tests": {
      "withItemIndex": {
        "description": "Select an item at a given positive index.",
        "input": {
          "list": ["a", "b", "c"],
          "index": 1
        },
        "expected": "b"
      },
      "withItemNegativeIndex": {
        "description": "Select an item at a given negative index from the end of the list.",
        "input": {
          "list": ["a", "b", "c"],
          "index": -2
        },
        "expected": "b"
      },
      "withItemIndexOutOfBounds": {
        "description": "Attempt to select an item at an index out of bounds.",
        "input": {
          "list": ["a", "b", "c"],
          "index": 5
        },
        "expected": null
      },
      "withItemNegativeIndexOutOfBounds": {
        "description": "Attempt to select an item at a negative index out of bounds.",
        "input": {
          "list": ["a", "b", "c"],
          "index": -5
        },
        "expected": null
      }
    }
  },
  {
    "define": "_functions.List.WithUniqueItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list containing each item in the input list, but only once.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The input list to process."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const seen = new Set();\nreturn $$args.input.filter((item) => {\n  if (seen.has(item)) {\n    return false;\n  }\n  seen.add(item);\n  return true;\n});\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The new list with unique items."
    },
    "tests": {
      "withUniqueItemSingle": {
        "description": "Return a new list with only one item.",
        "input": {
          "input": ["a"]
        },
        "expected": ["a"]
      },
      "withUniqueItemMulti": {
        "description": "Return a new list with multiple unique items.",
        "input": {
          "input": ["a", "b", "c", "d", "e", "b"]
        },
        "expected": ["a", "b", "c", "d", "e"]
      },
      "withUniqueItemEmpty": {
        "description": "Return a new list from an empty input list.",
        "input": {
          "input": []
        },
        "expected": []
      },
      "withUniqueItemAllDuplicates": {
        "description": "Return a new list when all items are duplicates.",
        "input": {
          "input": ["a", "a", "a"]
        },
        "expected": ["a"]
      },
      "withUniqueItemMixedTypes": {
        "description": "Return a new list with mixed types.",
        "input": {
          "input": [1, "1", 2, "2", 2, "2"]
        },
        "expected": [1, "1", 2, "2"]
      }
    }
  },
  {
    "define": "_functions.List.WithUniqueItemByKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list with unique items based on the given key.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The original list to filter."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to use for uniqueness."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const seen = new Set();\nreturn $$args.input.filter((item) => {\n  const keyValue = item[$$args.key];\n  if (seen.has(keyValue)) {\n    return false;\n  }\n  seen.add(keyValue);\n  return true;\n});\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A new list with unique items."
    },
    "tests": {
      "withUniqueItemByKeySimple": {
        "description": "Filter a simple list.",
        "input": {
          "input": [
            {
              "id": "1"
            },
            {
              "id": "2"
            },
            {
              "id": "1"
            }
          ],
          "key": "id"
        },
        "expected": [
          {
            "id": "1"
          },
          {
            "id": "2"
          }
        ]
      },
      "withUniqueItemByKeyComplex": {
        "description": "Filter a complex list.",
        "input": {
          "input": [
            {
              "name": "John",
              "age": 25
            },
            {
              "name": "Jane",
              "age": 30
            },
            {
              "name": "John",
              "age": 25
            }
          ],
          "key": "name"
        },
        "expected": [
          {
            "name": "John",
            "age": 25
          },
          {
            "name": "Jane",
            "age": 30
          }
        ]
      },
      "withUniqueItemByKeyNoDuplicates": {
        "description": "Filter a list with no duplicates.",
        "input": {
          "input": [
            {
              "id": "1"
            },
            {
              "id": "2"
            },
            {
              "id": "3"
            }
          ],
          "key": "id"
        },
        "expected": [
          {
            "id": "1"
          },
          {
            "id": "2"
          },
          {
            "id": "3"
          }
        ]
      },
      "withUniqueItemByKeyEmptyList": {
        "description": "Filter an empty list.",
        "input": {
          "input": [],
          "key": "id"
        },
        "expected": []
      },
      "withUniqueItemByKeyDifferentKeys": {
        "description": "Filter a list with different keys.",
        "input": {
          "input": [
            {
              "name": "John"
            },
            {
              "name": "Jane"
            },
            {
              "id": "1"
            }
          ],
          "key": "name"
        },
        "expected": [
          {
            "name": "John"
          },
          {
            "name": "Jane"
          },
          {
            "id": "1"
          }
        ]
      }
    }
  },
  {
    "define": "_functions.List.Without",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Removes specified values from a list.",
    "parameters": {
      "list": {
        "type": "_types.List",
        "description": "The list to remove values from.",
        "items": {
          "type": "_types.Unknown"
        }
      },
      "values": {
        "type": "_types.List",
        "description": "The values to remove.",
        "items": {
          "type": "_types.Unknown"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "const valuesSet = new Set($$args.values);\nreturn $$args.list.filter(item => !valuesSet.has(item));\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The list with the specified values removed.",
      "items": {
        "type": "_types.Unknown"
      }
    },
    "tests": {
      "withoutValues": {
        "description": "Remove specified values from a list.",
        "input": {
          "list": [1, 2, 3, 4, 5],
          "values": [2, 4]
        },
        "expected": [1, 3, 5]
      },
      "withoutNonExistingValues": {
        "description": "Try to remove values that do not exist in the list.",
        "input": {
          "list": [1, 2, 3],
          "values": [4, 5]
        },
        "expected": [1, 2, 3]
      },
      "withoutEmptyValues": {
        "description": "Remove from a list with an empty values list.",
        "input": {
          "list": [1, 2, 3],
          "values": []
        },
        "expected": [1, 2, 3]
      },
      "withoutEmptyList": {
        "description": "Remove from an empty list.",
        "input": {
          "list": [],
          "values": [1, 2]
        },
        "expected": []
      },
      "withoutAllValues": {
        "description": "Remove all values from a list.",
        "input": {
          "list": [1, 2, 3, 4],
          "values": [1, 2, 3, 4]
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.List.WithoutItem",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns a new list that excludes the given item.",
    "parameters": {
      "input": {
        "type": "_types.List",
        "description": "The list to search and remove an item from."
      },
      "item": {
        "type": "_types.Any",
        "description": "The item to exclude from the result."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.input.filter((x) => x !== $$args.item);\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "The new list without the specified item."
    },
    "tests": {
      "withoutItemPresent": {
        "description": "Remove an item that is present in the list.",
        "input": {
          "input": ["a", "b", "c"],
          "item": "b"
        },
        "expected": ["a", "c"]
      },
      "withoutItemNotPresent": {
        "description": "Attempt to remove an item that is not present in the list.",
        "input": {
          "input": ["a", "b", "c"],
          "item": "d"
        },
        "expected": ["a", "b", "c"]
      },
      "withoutItemMultipleOccurrences": {
        "description": "Remove an item that appears multiple times in the list.",
        "input": {
          "input": ["a", "b", "b", "c"],
          "item": "b"
        },
        "expected": ["a", "c"]
      },
      "withoutItemEmptyList": {
        "description": "Attempt to remove an item from an empty list.",
        "input": {
          "input": [],
          "item": "a"
        },
        "expected": []
      },
      "withoutItemSameTypeDifferentValue": {
        "description": "Attempt to remove an item with the same type but different value.",
        "input": {
          "input": [1, 2, 3],
          "item": "1"
        },
        "expected": [1, 2, 3]
      }
    }
  },
  {
    "define": "_functions.Math.Yearfrac",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Returns the year fraction for a given date.",
    "parameters": {
      "start_date": {
        "type": "_types.String",
        "description": "The start date in ISO format."
      },
      "end_date": {
        "type": "_types.String",
        "description": "The end date in ISO format."
      }
    },
    "implementation": {
      "javascript": {
        "code": "const startDate = new Date($$args.start_date);\nconst endDate = new Date($$args.end_date);\nconst duration = endDate - startDate;\nreturn (duration / (1000 * 60 * 60 * 24 * 365.25));\n"
      }
    },
    "returns": {
      "type": "_types.Number",
      "description": "The year fraction."
    },
    "tests": {
      "yearfracSimple": {
        "description": "Calculate the year fraction for a simple date range.",
        "input": {
          "start_date": "2022-01-01T00:00:00Z",
          "end_date": "2022-12-31T23:59:59.999Z"
        },
        "expected": 0.9993155372715289
      },
      "yearfracPartialYear": {
        "description": "Calculate the year fraction for a date range that spans two years.",
        "input": {
          "start_date": "2022-01-01T00:00:00Z",
          "end_date": "2023-06-30T23:59:59.999Z"
        },
        "expected": 1.4948665297424393
      },
      "yearfracNoDays": {
        "description": "Calculate the year fraction for a date range that is less than one day.",
        "input": {
          "start_date": "2022-01-01T00:00:00Z",
          "end_date": "2022-01-01T00:59:59.999Z"
        },
        "expected": 0.00011407708444241641
      }
    }
  },
  {
    "define": "_functions.List.Zip",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Combines two lists into a list of tuples.",
    "parameters": {
      "list1": {
        "type": "_types.List",
        "description": "The first list to combine.",
        "items": {
          "type": "_types.Any"
        }
      },
      "list2": {
        "type": "_types.List",
        "description": "The second list to combine.",
        "items": {
          "type": "_types.Any"
        }
      }
    },
    "implementation": {
      "javascript": {
        "code": "const minLength = Math.min($$args.list1.length, $$args.list2.length);\nconst result = [];\nfor (let i = 0; i < minLength; i++) {\n  result.push([$$args.list1[i], $$args.list2[i]]);\n}\nreturn result;\n"
      }
    },
    "returns": {
      "type": "_types.List",
      "description": "A list of tuples combining the elements of the two lists.",
      "items": {
        "type": "_types.Tuple",
        "items": [
          {
            "type": "_types.Any"
          },
          {
            "type": "_types.Any"
          }
        ]
      }
    },
    "tests": {
      "zipEqualLength": {
        "description": "Zip two lists of equal length.",
        "input": {
          "list1": [1, 2, 3],
          "list2": ["a", "b", "c"]
        },
        "expected": [
          [1, "a"],
          [2, "b"],
          [3, "c"]
        ]
      },
      "zipFirstLonger": {
        "description": "Zip two lists where the first list is longer.",
        "input": {
          "list1": [1, 2, 3, 4],
          "list2": ["a", "b"]
        },
        "expected": [
          [1, "a"],
          [2, "b"]
        ]
      },
      "zipSecondLonger": {
        "description": "Zip two lists where the second list is longer.",
        "input": {
          "list1": [1],
          "list2": ["a", "b", "c"]
        },
        "expected": [[1, "a"]]
      },
      "zipEmptyLists": {
        "description": "Zip two empty lists.",
        "input": {
          "list1": [],
          "list2": []
        },
        "expected": []
      }
    }
  },
  {
    "define": "_functions.Object.HasKey",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a key exists in an object.",
    "parameters": {
      "value": {
        "type": "_types.Dictionary",
        "description": "The object to check."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Object.prototype.hasOwnProperty.call($$args.value, $$args.key);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the key exists in the object, false otherwise."
    },
    "tests": {
      "hasKey": {
        "description": "Test with a key that exists in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": 2
          },
          "key": "a"
        },
        "expected": true
      },
      "doesNotHaveKey": {
        "description": "Test with a key that does not exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": 2
          },
          "key": "c"
        },
        "expected": false
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "value": {},
          "key": "a"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Object.HasKeyRecursive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a key exists in an object recursively.",
    "parameters": {
      "value": {
        "type": "_types.Dictionary",
        "description": "The object to check."
      },
      "key": {
        "type": "_types.String",
        "description": "The key to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hasKeyRecursive(obj, key) {\n  if (Object.prototype.hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  for (let i in obj) {\n    if (typeof obj[i] === 'object') {\n      if (hasKeyRecursive(obj[i], key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nreturn hasKeyRecursive($$args.value, $$args.key);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the key exists in the object, false otherwise."
    },
    "tests": {
      "hasKey": {
        "description": "Test with a key that exists in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": 2
            }
          },
          "key": "c"
        },
        "expected": true
      },
      "doesNotHaveKey": {
        "description": "Test with a key that does not exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": 2
            }
          },
          "key": "d"
        },
        "expected": false
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "value": {},
          "key": "a"
        },
        "expected": false
      },
      "threeLevelObject": {
        "description": "Test with a three-level object.",
        "input": {
          "value": {
            "a": {
              "b": {
                "c": 1
              }
            }
          },
          "key": "c"
        },
        "expected": true
      }
    }
  },
  {
    "define": "_functions.Logical.HasKeys",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if keys exist in an object.",
    "parameters": {
      "value": {
        "type": "_types.Object",
        "description": "The object to check."
      },
      "keys": {
        "type": "_types.List",
        "description": "The keys to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.keys.every(key => $$args.value.hasOwnProperty(key));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if all keys exist in the object, false otherwise."
    },
    "tests": {
      "hasKeys": {
        "description": "Check if keys exist in an object.",
        "input": {
          "value": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "keys": ["a", "b"]
        },
        "expected": true
      },
      "missingKeys": {
        "description": "Check if keys exist in an object.",
        "input": {
          "value": {
            "a": 1,
            "b": 2,
            "c": 3
          },
          "keys": ["a", "d"]
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Object.HasKeysRecursive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if keys exist in an object recursively.",
    "parameters": {
      "value": {
        "type": "_types.Object",
        "description": "The object to check."
      },
      "keys": {
        "type": "_types.List",
        "description": "The keys to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hasKeyRecursive(obj, key) {\n  if (Object.prototype.hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  for (let i in obj) {\n    if (typeof obj[i] === 'object') {\n      if (hasKeyRecursive(obj[i], key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nreturn $$args.keys.every(key => hasKeyRecursive($$args.value, key));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if all keys exist in the object, false otherwise."
    },
    "tests": {
      "hasKeys": {
        "description": "Test with keys that exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": 2,
              "d": 3
            }
          },
          "keys": ["a", "c"]
        },
        "expected": true
      },
      "missingKeys": {
        "description": "Test with keys that do not exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": 2,
              "d": 3
            }
          },
          "keys": ["a", "e"]
        },
        "expected": false
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "value": {},
          "keys": ["a"]
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.HasValue",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the input object has a value.",
    "parameters": {
      "value": {
        "type": "_types.Dictionary",
        "description": "The object to check."
      },
      "valueKey": {
        "type": "_types.Any",
        "description": "The key of the value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return Object.values($$args.value).includes($$args.valueKey);\n"
      }
    },
    "tests": {
      "HasStringValue": {
        "description": "Check if the object has a value.",
        "input": {
          "value": {
            "key": "value"
          },
          "valueKey": "value"
        },
        "expected": true
      },
      "HasNumberValue": {
        "description": "Check if the object has a value.",
        "input": {
          "value": {
            "key": 1
          },
          "valueKey": 1
        },
        "expected": true
      },
      "NotHasStringValue": {
        "description": "Check if the object has a value.",
        "input": {
          "value": {
            "key": "value"
          },
          "valueKey": "noValue"
        },
        "expected": false
      },
      "NotHasNumberValue": {
        "description": "Check if the object has a value.",
        "input": {
          "value": {
            "key": 1
          },
          "valueKey": 2
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Object.HasValueRecursive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if a value exists in an object recursively.",
    "parameters": {
      "value": {
        "type": "_types.Dictionary",
        "description": "The object to check."
      },
      "valueKey": {
        "type": "_types.Any",
        "description": "The value to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hasValueRecursive(obj, valueKey) {\n  if (Object.values(obj).includes(valueKey)) {\n    return true;\n  }\n  for (let i in obj) {\n    if (typeof obj[i] === 'object') {\n      if (hasValueRecursive(obj[i], valueKey)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nreturn hasValueRecursive($$args.value, $$args.valueKey);\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if the value exists in the object, false otherwise."
    },
    "tests": {
      "hasValue": {
        "description": "Test with a value that exists in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": "2",
              "d": 3
            }
          },
          "valueKey": "2"
        },
        "expected": true
      },
      "doesNotHaveValue": {
        "description": "Test with a value that does not exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": "2",
              "d": 3
            }
          },
          "valueKey": "4"
        },
        "expected": false
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "value": {},
          "valueKey": "1"
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Math.HasValues",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the input object has certain values.",
    "parameters": {
      "value": {
        "type": "_types.Dictionary",
        "description": "The object to check."
      },
      "valueKeys": {
        "type": "_types.List",
        "description": "The keys of the values to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return $$args.valueKeys.every(valueKey => Object.values($$args.value).includes(valueKey));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if all values exist in the object, false otherwise."
    },
    "tests": {
      "HasStringValues": {
        "description": "Check if the object has certain values.",
        "input": {
          "value": {
            "key1": "value1",
            "key2": "value2"
          },
          "valueKeys": ["value1", "value2"]
        },
        "expected": true
      },
      "HasNumberValues": {
        "description": "Check if the object has certain values.",
        "input": {
          "value": {
            "key1": 1,
            "key2": 2
          },
          "valueKeys": [1, 2]
        },
        "expected": true
      },
      "NotHasStringValues": {
        "description": "Check if the object has certain values.",
        "input": {
          "value": {
            "key1": "value1",
            "key2": "value2"
          },
          "valueKeys": ["value1", "noValue"]
        },
        "expected": false
      },
      "NotHasNumberValues": {
        "description": "Check if the object has certain values.",
        "input": {
          "value": {
            "key1": 1,
            "key2": 2
          },
          "valueKeys": [1, 3]
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Object.HasValuesRecursive",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if values exist in an object recursively.",
    "parameters": {
      "value": {
        "type": "_types.Object",
        "description": "The object to check."
      },
      "valueKeys": {
        "type": "_types.List",
        "description": "The values to check for."
      }
    },
    "implementation": {
      "javascript": {
        "code": "function hasValueRecursive(obj, valueKey) {\n  if (Object.values(obj).includes(valueKey)) {\n    return true;\n  }\n  for (let i in obj) {\n    if (typeof obj[i] === 'object') {\n      if (hasValueRecursive(obj[i], valueKey)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nreturn $$args.valueKeys.every(valueKey => hasValueRecursive($$args.value, valueKey));\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "True if all values exist in the object, false otherwise."
    },
    "tests": {
      "hasValues": {
        "description": "Test with values that exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": "2",
              "d": 3
            }
          },
          "valueKeys": ["2", 1]
        },
        "expected": true
      },
      "missingValues": {
        "description": "Test with values that do not exist in the object.",
        "input": {
          "value": {
            "a": 1,
            "b": {
              "c": "2",
              "d": 3
            }
          },
          "valueKeys": ["4", 1]
        },
        "expected": false
      },
      "emptyObject": {
        "description": "Test with an empty object.",
        "input": {
          "value": {},
          "valueKeys": ["1"]
        },
        "expected": false
      }
    }
  },
  {
    "define": "_functions.Object.IsObject",
    "blueprint": "_blueprint.Flowgraph",
    "description": "Checks if the provided input is an object.",
    "parameters": {
      "value": {
        "type": "_types.Any",
        "description": "The value to check."
      }
    },
    "implementation": {
      "javascript": {
        "code": "return typeof $$args.value === 'object' && $$args.value !== null;\n"
      }
    },
    "returns": {
      "type": "_types.Boolean",
      "description": "Whether the provided input is an object."
    },
    "tests": {
      "isObject": {
        "description": "Check if the provided input is an object.",
        "input": {
          "value": {
            "a": 1
          }
        },
        "expected": true
      },
      "isNotObject": {
        "description": "Check if the provided input is not an object.",
        "input": {
          "value": 1
        },
        "expected": false
      },
      "isNestedObject": {
        "description": "Check if the provided input is a nested object.",
        "input": {
          "value": {
            "a": {
              "b": 1
            }
          }
        },
        "expected": true
      }
    }
  }
]
